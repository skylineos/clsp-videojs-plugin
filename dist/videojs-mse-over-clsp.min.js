!function(e){var n={};function t(s){if(n[s])return n[s].exports;var o=n[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,s){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:s})},t.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./src/js/videojs-mse-over-clsp.js")}({"./node_modules/debug/src/browser.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch (e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?")},"./node_modules/debug/src/debug.js":function(module,exports,__webpack_require__){eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n      i;\n\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy() {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n//# sourceURL=webpack:///./node_modules/debug/src/debug.js?")},"./node_modules/global/document.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var topLevel = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\nvar minDoc = __webpack_require__(/*! min-document */ 0);\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/global/document.js?")},"./node_modules/ms/index.js":function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?")},"./node_modules/node-libs-browser/node_modules/process/browser.js":function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/process/browser.js?")},"./node_modules/paho-mqtt/mqttws31-min.js":function(module,exports){eval('var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n/*******************************************************************************\n * Copyright (c) 2013, 2014 IBM Corp.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v1.0 which accompany this distribution. \n *\n * The Eclipse Public License is available at \n *    http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at \n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n *******************************************************************************/\n\n"undefined" === typeof Paho && (Paho = {});\nPaho.MQTT = function (t) {\n  function x(a, b, c) {\n    b[c++] = a >> 8;b[c++] = a % 256;return c;\n  }function r(a, b, c, h) {\n    h = x(b, c, h);E(a, c, h);return h + b;\n  }function m(a) {\n    for (var b = 0, c = 0; c < a.length; c++) {\n      var h = a.charCodeAt(c);2047 < h ? (55296 <= h && 56319 >= h && (c++, b++), b += 3) : 127 < h ? b += 2 : b++;\n    }return b;\n  }function E(a, b, c) {\n    for (var h = 0; h < a.length; h++) {\n      var e = a.charCodeAt(h);if (55296 <= e && 56319 >= e) {\n        var d = a.charCodeAt(++h);if (isNaN(d)) throw Error(f(g.MALFORMED_UNICODE, [e, d]));e = (e - 55296 << 10) + (d - 56320) + 65536;\n      }127 >= e ? b[c++] = e : (2047 >= e ? b[c++] = e >> 6 & 31 | 192 : (65535 >= e ? b[c++] = e >> 12 & 15 | 224 : (b[c++] = e >> 18 & 7 | 240, b[c++] = e >> 12 & 63 | 128), b[c++] = e >> 6 & 63 | 128), b[c++] = e & 63 | 128);\n    }return b;\n  }function F(a, b, c) {\n    for (var h = "", e, d = b; d < b + c;) {\n      e = a[d++];if (!(128 > e)) {\n        var p = a[d++] - 128;if (0 > p) throw Error(f(g.MALFORMED_UTF, [e.toString(16), p.toString(16), ""]));if (224 > e) e = 64 * (e - 192) + p;else {\n          var s = a[d++] - 128;if (0 > s) throw Error(f(g.MALFORMED_UTF, [e.toString(16), p.toString(16), s.toString(16)]));if (240 > e) e = 4096 * (e - 224) + 64 * p + s;else {\n            var l = a[d++] - 128;if (0 > l) throw Error(f(g.MALFORMED_UTF, [e.toString(16), p.toString(16), s.toString(16), l.toString(16)]));if (248 > e) e = 262144 * (e - 240) + 4096 * p + 64 * s + l;else throw Error(f(g.MALFORMED_UTF, [e.toString(16), p.toString(16), s.toString(16), l.toString(16)]));\n          }\n        }\n      }65535 < e && (e -= 65536, h += String.fromCharCode(55296 + (e >> 10)), e = 56320 + (e & 1023));h += String.fromCharCode(e);\n    }return h;\n  }var z = function z(a, b) {\n    for (var c in a) {\n      if (a.hasOwnProperty(c)) if (b.hasOwnProperty(c)) {\n        if (_typeof(a[c]) !== b[c]) throw Error(f(g.INVALID_TYPE, [_typeof(a[c]), c]));\n      } else {\n        var h = "Unknown property, " + c + ". Valid properties are:";for (c in b) {\n          b.hasOwnProperty(c) && (h = h + " " + c);\n        }throw Error(h);\n      }\n    }\n  },\n      q = function q(a, b) {\n    return function () {\n      return a.apply(b, arguments);\n    };\n  },\n      g = { OK: { code: 0, text: "AMQJSC0000I OK." }, CONNECT_TIMEOUT: { code: 1, text: "AMQJSC0001E Connect timed out." }, SUBSCRIBE_TIMEOUT: { code: 2, text: "AMQJS0002E Subscribe timed out." }, UNSUBSCRIBE_TIMEOUT: { code: 3, text: "AMQJS0003E Unsubscribe timed out." }, PING_TIMEOUT: { code: 4, text: "AMQJS0004E Ping timed out." }, INTERNAL_ERROR: { code: 5, text: "AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}" },\n    CONNACK_RETURNCODE: { code: 6, text: "AMQJS0006E Bad Connack return code:{0} {1}." }, SOCKET_ERROR: { code: 7, text: "AMQJS0007E Socket error:{0}." }, SOCKET_CLOSE: { code: 8, text: "AMQJS0008I Socket closed." }, MALFORMED_UTF: { code: 9, text: "AMQJS0009E Malformed UTF data:{0} {1} {2}." }, UNSUPPORTED: { code: 10, text: "AMQJS0010E {0} is not supported by this browser." }, INVALID_STATE: { code: 11, text: "AMQJS0011E Invalid state {0}." }, INVALID_TYPE: { code: 12, text: "AMQJS0012E Invalid type {0} for {1}." }, INVALID_ARGUMENT: { code: 13, text: "AMQJS0013E Invalid argument {0} for {1}." },\n    UNSUPPORTED_OPERATION: { code: 14, text: "AMQJS0014E Unsupported operation." }, INVALID_STORED_DATA: { code: 15, text: "AMQJS0015E Invalid data in local storage key\\x3d{0} value\\x3d{1}." }, INVALID_MQTT_MESSAGE_TYPE: { code: 16, text: "AMQJS0016E Invalid MQTT message type {0}." }, MALFORMED_UNICODE: { code: 17, text: "AMQJS0017E Malformed Unicode string:{0} {1}." } },\n      I = { 0: "Connection Accepted", 1: "Connection Refused: unacceptable protocol version", 2: "Connection Refused: identifier rejected", 3: "Connection Refused: server unavailable",\n    4: "Connection Refused: bad user name or password", 5: "Connection Refused: not authorized" },\n      f = function f(a, b) {\n    var c = a.text;if (b) for (var h, e, d = 0; d < b.length; d++) {\n      if (h = "{" + d + "}", e = c.indexOf(h), 0 < e) var g = c.substring(0, e),\n          c = c.substring(e + h.length),\n          c = g + b[d] + c;\n    }return c;\n  },\n      A = [0, 6, 77, 81, 73, 115, 100, 112, 3],\n      B = [0, 4, 77, 81, 84, 84, 4],\n      n = function n(a, b) {\n    this.type = a;for (var c in b) {\n      b.hasOwnProperty(c) && (this[c] = b[c]);\n    }\n  };n.prototype.encode = function () {\n    var a = (this.type & 15) << 4,\n        b = 0,\n        c = [],\n        h = 0;void 0 != this.messageIdentifier && (b += 2);switch (this.type) {case 1:\n        switch (this.mqttVersion) {case 3:\n            b += A.length + 3;break;case 4:\n            b += B.length + 3;}b += m(this.clientId) + 2;if (void 0 != this.willMessage) {\n          var b = b + (m(this.willMessage.destinationName) + 2),\n              e = this.willMessage.payloadBytes;e instanceof Uint8Array || (e = new Uint8Array(g));b += e.byteLength + 2;\n        }void 0 != this.userName && (b += m(this.userName) + 2);void 0 != this.password && (b += m(this.password) + 2);break;case 8:\n        for (var a = a | 2, d = 0; d < this.topics.length; d++) {\n          c[d] = m(this.topics[d]), b += c[d] + 2;\n        }b += this.requestedQos.length;break;case 10:\n        a |= 2;for (d = 0; d < this.topics.length; d++) {\n          c[d] = m(this.topics[d]), b += c[d] + 2;\n        }break;case 6:\n        a |= 2;break;case 3:\n        this.payloadMessage.duplicate && (a |= 8);a = a |= this.payloadMessage.qos << 1;this.payloadMessage.retained && (a |= 1);var h = m(this.payloadMessage.destinationName),\n            g = this.payloadMessage.payloadBytes,\n            b = b + (h + 2) + g.byteLength;g instanceof ArrayBuffer ? g = new Uint8Array(g) : g instanceof Uint8Array || (g = new Uint8Array(g.buffer));}var f = b,\n        d = Array(1),\n        l = 0;do {\n      var y = f % 128,\n          f = f >> 7;0 < f && (y |= 128);d[l++] = y;\n    } while (0 < f && 4 > l);f = d.length + 1;b = new ArrayBuffer(b + f);l = new Uint8Array(b);\n    l[0] = a;l.set(d, 1);if (3 == this.type) f = r(this.payloadMessage.destinationName, h, l, f);else if (1 == this.type) {\n      switch (this.mqttVersion) {case 3:\n          l.set(A, f);f += A.length;break;case 4:\n          l.set(B, f), f += B.length;}a = 0;this.cleanSession && (a = 2);void 0 != this.willMessage && (a = a | 4 | this.willMessage.qos << 3, this.willMessage.retained && (a |= 32));void 0 != this.userName && (a |= 128);void 0 != this.password && (a |= 64);l[f++] = a;f = x(this.keepAliveInterval, l, f);\n    }void 0 != this.messageIdentifier && (f = x(this.messageIdentifier, l, f));switch (this.type) {case 1:\n        f = r(this.clientId, m(this.clientId), l, f);void 0 != this.willMessage && (f = r(this.willMessage.destinationName, m(this.willMessage.destinationName), l, f), f = x(e.byteLength, l, f), l.set(e, f), f += e.byteLength);void 0 != this.userName && (f = r(this.userName, m(this.userName), l, f));void 0 != this.password && r(this.password, m(this.password), l, f);break;case 3:\n        l.set(g, f);break;case 8:\n        for (d = 0; d < this.topics.length; d++) {\n          f = r(this.topics[d], c[d], l, f), l[f++] = this.requestedQos[d];\n        }break;case 10:\n        for (d = 0; d < this.topics.length; d++) {\n          f = r(this.topics[d], c[d], l, f);\n        }}return b;\n  };var G = function G(a, b, c) {\n    this._client = a;this._window = b;this._keepAliveInterval = 1E3 * c;this.isReset = !1;var h = new n(12).encode(),\n        e = function e(a) {\n      return function () {\n        return d.apply(a);\n      };\n    },\n        d = function d() {\n      this.isReset ? (this.isReset = !1, this._client._trace("Pinger.doPing", "send PINGREQ"), this._client.socket.send(h), this.timeout = this._window.setTimeout(e(this), this._keepAliveInterval)) : (this._client._trace("Pinger.doPing", "Timed out"), this._client._disconnected(g.PING_TIMEOUT.code, f(g.PING_TIMEOUT)));\n    };\n    this.reset = function () {\n      this.isReset = !0;this._window.clearTimeout(this.timeout);0 < this._keepAliveInterval && (this.timeout = setTimeout(e(this), this._keepAliveInterval));\n    };this.cancel = function () {\n      this._window.clearTimeout(this.timeout);\n    };\n  },\n      C = function C(a, b, c, f, e) {\n    this._window = b;c || (c = 30);this.timeout = setTimeout(function (a, b, c) {\n      return function () {\n        return a.apply(b, c);\n      };\n    }(f, a, e), 1E3 * c);this.cancel = function () {\n      this._window.clearTimeout(this.timeout);\n    };\n  },\n      k = function k(a, b, c, h, e) {\n    if (!("WebSocket" in t && null !== t.WebSocket)) throw Error(f(g.UNSUPPORTED, ["WebSocket"]));if (!("localStorage" in t && null !== t.localStorage)) throw Error(f(g.UNSUPPORTED, ["localStorage"]));if (!("ArrayBuffer" in t && null !== t.ArrayBuffer)) throw Error(f(g.UNSUPPORTED, ["ArrayBuffer"]));this._trace("Paho.MQTT.Client", a, b, c, h, e);this.host = b;this.port = c;this.path = h;this.uri = a;this.clientId = e;this._localKey = b + ":" + c + ("/mqtt" != h ? ":" + h : "") + ":" + e + ":";this._msg_queue = [];this._sentMessages = {};this._receivedMessages = {};this._notify_msg_sent = {};this._message_identifier = 1;this._sequence = 0;for (var d in localStorage) {\n      0 != d.indexOf("Sent:" + this._localKey) && 0 != d.indexOf("Received:" + this._localKey) || this.restore(d);\n    }\n  };k.prototype.host;k.prototype.port;k.prototype.path;k.prototype.uri;k.prototype.clientId;k.prototype.socket;k.prototype.connected = !1;k.prototype.maxMessageIdentifier = 65536;k.prototype.connectOptions;k.prototype.hostIndex;k.prototype.onConnectionLost;k.prototype.onMessageDelivered;k.prototype.onMessageArrived;k.prototype.traceFunction;k.prototype._msg_queue = null;k.prototype._connectTimeout;k.prototype.sendPinger = null;k.prototype.receivePinger = null;k.prototype.receiveBuffer = null;k.prototype._traceBuffer = null;k.prototype._MAX_TRACE_ENTRIES = 100;k.prototype.connect = function (a) {\n    var b = this._traceMask(a, "password");this._trace("Client.connect", b, this.socket, this.connected);if (this.connected) throw Error(f(g.INVALID_STATE, ["already connected"]));if (this.socket) throw Error(f(g.INVALID_STATE, ["already connected"]));this.connectOptions = a;a.uris ? (this.hostIndex = 0, this._doConnect(a.uris[0])) : this._doConnect(this.uri);\n  };\n  k.prototype.subscribe = function (a, b) {\n    this._trace("Client.subscribe", a, b);if (!this.connected) throw Error(f(g.INVALID_STATE, ["not connected"]));var c = new n(8);c.topics = [a];c.requestedQos = void 0 != b.qos ? [b.qos] : [0];b.onSuccess && (c.onSuccess = function (a) {\n      b.onSuccess({ invocationContext: b.invocationContext, grantedQos: a });\n    });b.onFailure && (c.onFailure = function (a) {\n      b.onFailure({ invocationContext: b.invocationContext, errorCode: a });\n    });b.timeout && (c.timeOut = new C(this, window, b.timeout, b.onFailure, [{ invocationContext: b.invocationContext,\n      errorCode: g.SUBSCRIBE_TIMEOUT.code, errorMessage: f(g.SUBSCRIBE_TIMEOUT) }]));this._requires_ack(c);this._schedule_message(c);\n  };k.prototype.unsubscribe = function (a, b) {\n    this._trace("Client.unsubscribe", a, b);if (!this.connected) throw Error(f(g.INVALID_STATE, ["not connected"]));var c = new n(10);c.topics = [a];b.onSuccess && (c.callback = function () {\n      b.onSuccess({ invocationContext: b.invocationContext });\n    });b.timeout && (c.timeOut = new C(this, window, b.timeout, b.onFailure, [{ invocationContext: b.invocationContext, errorCode: g.UNSUBSCRIBE_TIMEOUT.code,\n      errorMessage: f(g.UNSUBSCRIBE_TIMEOUT) }]));this._requires_ack(c);this._schedule_message(c);\n  };k.prototype.send = function (a) {\n    this._trace("Client.send", a);if (!this.connected) throw Error(f(g.INVALID_STATE, ["not connected"]));wireMessage = new n(3);wireMessage.payloadMessage = a;0 < a.qos ? this._requires_ack(wireMessage) : this.onMessageDelivered && (this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage));this._schedule_message(wireMessage);\n  };k.prototype.disconnect = function () {\n    this._trace("Client.disconnect");\n    if (!this.socket) throw Error(f(g.INVALID_STATE, ["not connecting or connected"]));wireMessage = new n(14);this._notify_msg_sent[wireMessage] = q(this._disconnected, this);this._schedule_message(wireMessage);\n  };k.prototype.getTraceLog = function () {\n    if (null !== this._traceBuffer) {\n      this._trace("Client.getTraceLog", new Date());this._trace("Client.getTraceLog in flight messages", this._sentMessages.length);for (var a in this._sentMessages) {\n        this._trace("_sentMessages ", a, this._sentMessages[a]);\n      }for (a in this._receivedMessages) {\n        this._trace("_receivedMessages ", a, this._receivedMessages[a]);\n      }return this._traceBuffer;\n    }\n  };k.prototype.startTrace = function () {\n    null === this._traceBuffer && (this._traceBuffer = []);this._trace("Client.startTrace", new Date(), "1.0.2");\n  };k.prototype.stopTrace = function () {\n    delete this._traceBuffer;\n  };k.prototype._doConnect = function (a) {\n    this.connectOptions.useSSL && (a = a.split(":"), a[0] = "wss", a = a.join(":"));this.connected = !1;this.socket = 4 > this.connectOptions.mqttVersion ? new WebSocket(a, ["mqttv3.1"]) : new WebSocket(a, ["mqtt"]);this.socket.binaryType = "arraybuffer";this.socket.onopen = q(this._on_socket_open, this);this.socket.onmessage = q(this._on_socket_message, this);this.socket.onerror = q(this._on_socket_error, this);this.socket.onclose = q(this._on_socket_close, this);this.sendPinger = new G(this, window, this.connectOptions.keepAliveInterval);this.receivePinger = new G(this, window, this.connectOptions.keepAliveInterval);this._connectTimeout = new C(this, window, this.connectOptions.timeout, this._disconnected, [g.CONNECT_TIMEOUT.code, f(g.CONNECT_TIMEOUT)]);\n  };k.prototype._schedule_message = function (a) {\n    this._msg_queue.push(a);this.connected && this._process_queue();\n  };k.prototype.store = function (a, b) {\n    var c = { type: b.type, messageIdentifier: b.messageIdentifier, version: 1 };switch (b.type) {case 3:\n        b.pubRecReceived && (c.pubRecReceived = !0);c.payloadMessage = {};for (var h = "", e = b.payloadMessage.payloadBytes, d = 0; d < e.length; d++) {\n          h = 15 >= e[d] ? h + "0" + e[d].toString(16) : h + e[d].toString(16);\n        }c.payloadMessage.payloadHex = h;c.payloadMessage.qos = b.payloadMessage.qos;c.payloadMessage.destinationName = b.payloadMessage.destinationName;\n        b.payloadMessage.duplicate && (c.payloadMessage.duplicate = !0);b.payloadMessage.retained && (c.payloadMessage.retained = !0);0 == a.indexOf("Sent:") && (void 0 === b.sequence && (b.sequence = ++this._sequence), c.sequence = b.sequence);break;default:\n        throw Error(f(g.INVALID_STORED_DATA, [key, c]));}localStorage.setItem(a + this._localKey + b.messageIdentifier, JSON.stringify(c));\n  };k.prototype.restore = function (a) {\n    var b = localStorage.getItem(a),\n        c = JSON.parse(b),\n        h = new n(c.type, c);switch (c.type) {case 3:\n        for (var b = c.payloadMessage.payloadHex, e = new ArrayBuffer(b.length / 2), e = new Uint8Array(e), d = 0; 2 <= b.length;) {\n          var k = parseInt(b.substring(0, 2), 16),\n              b = b.substring(2, b.length);e[d++] = k;\n        }b = new Paho.MQTT.Message(e);b.qos = c.payloadMessage.qos;b.destinationName = c.payloadMessage.destinationName;c.payloadMessage.duplicate && (b.duplicate = !0);c.payloadMessage.retained && (b.retained = !0);h.payloadMessage = b;break;default:\n        throw Error(f(g.INVALID_STORED_DATA, [a, b]));}0 == a.indexOf("Sent:" + this._localKey) ? (h.payloadMessage.duplicate = !0, this._sentMessages[h.messageIdentifier] = h) : 0 == a.indexOf("Received:" + this._localKey) && (this._receivedMessages[h.messageIdentifier] = h);\n  };k.prototype._process_queue = function () {\n    for (var a = null, b = this._msg_queue.reverse(); a = b.pop();) {\n      this._socket_send(a), this._notify_msg_sent[a] && (this._notify_msg_sent[a](), delete this._notify_msg_sent[a]);\n    }\n  };k.prototype._requires_ack = function (a) {\n    var b = Object.keys(this._sentMessages).length;if (b > this.maxMessageIdentifier) throw Error("Too many messages:" + b);for (; void 0 !== this._sentMessages[this._message_identifier];) {\n      this._message_identifier++;\n    }a.messageIdentifier = this._message_identifier;this._sentMessages[a.messageIdentifier] = a;3 === a.type && this.store("Sent:", a);this._message_identifier === this.maxMessageIdentifier && (this._message_identifier = 1);\n  };k.prototype._on_socket_open = function () {\n    var a = new n(1, this.connectOptions);a.clientId = this.clientId;this._socket_send(a);\n  };k.prototype._on_socket_message = function (a) {\n    this._trace("Client._on_socket_message", a.data);a = this._deframeMessages(a.data);for (var b = 0; b < a.length; b += 1) {\n      this._handleMessage(a[b]);\n    }\n  };\n  k.prototype._deframeMessages = function (a) {\n    a = new Uint8Array(a);if (this.receiveBuffer) {\n      var b = new Uint8Array(this.receiveBuffer.length + a.length);b.set(this.receiveBuffer);b.set(a, this.receiveBuffer.length);a = b;delete this.receiveBuffer;\n    }try {\n      for (var b = 0, c = []; b < a.length;) {\n        var h;a: {\n          var e = a,\n              d = b,\n              k = d,\n              s = e[d],\n              l = s >> 4,\n              y = s & 15,\n              d = d + 1,\n              u = void 0,\n              D = 0,\n              m = 1;do {\n            if (d == e.length) {\n              h = [null, k];break a;\n            }u = e[d++];D += (u & 127) * m;m *= 128;\n          } while (0 != (u & 128));u = d + D;if (u > e.length) h = [null, k];else {\n            var v = new n(l);switch (l) {case 2:\n                e[d++] & 1 && (v.sessionPresent = !0);v.returnCode = e[d++];break;case 3:\n                var k = y >> 1 & 3,\n                    r = 256 * e[d] + e[d + 1],\n                    d = d + 2,\n                    t = F(e, d, r),\n                    d = d + r;0 < k && (v.messageIdentifier = 256 * e[d] + e[d + 1], d += 2);var q = new Paho.MQTT.Message(e.subarray(d, u));1 == (y & 1) && (q.retained = !0);8 == (y & 8) && (q.duplicate = !0);q.qos = k;q.destinationName = t;v.payloadMessage = q;break;case 4:case 5:case 6:case 7:case 11:\n                v.messageIdentifier = 256 * e[d] + e[d + 1];break;case 9:\n                v.messageIdentifier = 256 * e[d] + e[d + 1], d += 2, v.returnCode = e.subarray(d, u);}h = [v, u];\n          }\n        }var w = h[0],\n            b = h[1];if (null !== w) c.push(w);else break;\n      }b < a.length && (this.receiveBuffer = a.subarray(b));\n    } catch (x) {\n      this._disconnected(g.INTERNAL_ERROR.code, f(g.INTERNAL_ERROR, [x.message, x.stack.toString()]));return;\n    }return c;\n  };k.prototype._handleMessage = function (a) {\n    this._trace("Client._handleMessage", a);try {\n      switch (a.type) {case 2:\n          this._connectTimeout.cancel();if (this.connectOptions.cleanSession) {\n            for (var b in this._sentMessages) {\n              var c = this._sentMessages[b];localStorage.removeItem("Sent:" + this._localKey + c.messageIdentifier);\n            }this._sentMessages = {};for (b in this._receivedMessages) {\n              var h = this._receivedMessages[b];localStorage.removeItem("Received:" + this._localKey + h.messageIdentifier);\n            }this._receivedMessages = {};\n          }if (0 === a.returnCode) this.connected = !0, this.connectOptions.uris && (this.hostIndex = this.connectOptions.uris.length);else {\n            this._disconnected(g.CONNACK_RETURNCODE.code, f(g.CONNACK_RETURNCODE, [a.returnCode, I[a.returnCode]]));break;\n          }a = [];for (var e in this._sentMessages) {\n            this._sentMessages.hasOwnProperty(e) && a.push(this._sentMessages[e]);\n          }a = a.sort(function (a, b) {\n            return a.sequence - b.sequence;\n          });\n          e = 0;for (var d = a.length; e < d; e++) {\n            if (c = a[e], 3 == c.type && c.pubRecReceived) {\n              var k = new n(6, { messageIdentifier: c.messageIdentifier });this._schedule_message(k);\n            } else this._schedule_message(c);\n          }if (this.connectOptions.onSuccess) this.connectOptions.onSuccess({ invocationContext: this.connectOptions.invocationContext });this._process_queue();break;case 3:\n          this._receivePublish(a);break;case 4:\n          if (c = this._sentMessages[a.messageIdentifier]) if (delete this._sentMessages[a.messageIdentifier], localStorage.removeItem("Sent:" + this._localKey + a.messageIdentifier), this.onMessageDelivered) this.onMessageDelivered(c.payloadMessage);break;case 5:\n          if (c = this._sentMessages[a.messageIdentifier]) c.pubRecReceived = !0, k = new n(6, { messageIdentifier: a.messageIdentifier }), this.store("Sent:", c), this._schedule_message(k);break;case 6:\n          h = this._receivedMessages[a.messageIdentifier];localStorage.removeItem("Received:" + this._localKey + a.messageIdentifier);h && (this._receiveMessage(h), delete this._receivedMessages[a.messageIdentifier]);var m = new n(7, { messageIdentifier: a.messageIdentifier });this._schedule_message(m);break;case 7:\n          c = this._sentMessages[a.messageIdentifier];delete this._sentMessages[a.messageIdentifier];localStorage.removeItem("Sent:" + this._localKey + a.messageIdentifier);if (this.onMessageDelivered) this.onMessageDelivered(c.payloadMessage);break;case 9:\n          if (c = this._sentMessages[a.messageIdentifier]) {\n            c.timeOut && c.timeOut.cancel();if (128 === a.returnCode[0]) {\n              if (c.onFailure) c.onFailure(a.returnCode);\n            } else if (c.onSuccess) c.onSuccess(a.returnCode);\n            delete this._sentMessages[a.messageIdentifier];\n          }break;case 11:\n          if (c = this._sentMessages[a.messageIdentifier]) c.timeOut && c.timeOut.cancel(), c.callback && c.callback(), delete this._sentMessages[a.messageIdentifier];break;case 13:\n          this.sendPinger.reset();break;case 14:\n          this._disconnected(g.INVALID_MQTT_MESSAGE_TYPE.code, f(g.INVALID_MQTT_MESSAGE_TYPE, [a.type]));break;default:\n          this._disconnected(g.INVALID_MQTT_MESSAGE_TYPE.code, f(g.INVALID_MQTT_MESSAGE_TYPE, [a.type]));}\n    } catch (l) {\n      this._disconnected(g.INTERNAL_ERROR.code, f(g.INTERNAL_ERROR, [l.message, l.stack.toString()]));\n    }\n  };k.prototype._on_socket_error = function (a) {\n    this._disconnected(g.SOCKET_ERROR.code, f(g.SOCKET_ERROR, [a.data]));\n  };k.prototype._on_socket_close = function () {\n    this._disconnected(g.SOCKET_CLOSE.code, f(g.SOCKET_CLOSE));\n  };k.prototype._socket_send = function (a) {\n    if (1 == a.type) {\n      var b = this._traceMask(a, "password");this._trace("Client._socket_send", b);\n    } else this._trace("Client._socket_send", a);this.socket.send(a.encode());this.sendPinger.reset();\n  };k.prototype._receivePublish = function (a) {\n    switch (a.payloadMessage.qos) {case "undefined":case 0:\n        this._receiveMessage(a);break;case 1:\n        var b = new n(4, { messageIdentifier: a.messageIdentifier });this._schedule_message(b);this._receiveMessage(a);break;case 2:\n        this._receivedMessages[a.messageIdentifier] = a;this.store("Received:", a);a = new n(5, { messageIdentifier: a.messageIdentifier });this._schedule_message(a);break;default:\n        throw Error("Invaild qos\\x3d" + wireMmessage.payloadMessage.qos);}\n  };k.prototype._receiveMessage = function (a) {\n    if (this.onMessageArrived) this.onMessageArrived(a.payloadMessage);\n  };\n  k.prototype._disconnected = function (a, b) {\n    this._trace("Client._disconnected", a, b);this.sendPinger.cancel();this.receivePinger.cancel();this._connectTimeout && this._connectTimeout.cancel();this._msg_queue = [];this._notify_msg_sent = {};this.socket && (this.socket.onopen = null, this.socket.onmessage = null, this.socket.onerror = null, this.socket.onclose = null, 1 === this.socket.readyState && this.socket.close(), delete this.socket);if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) this.hostIndex++, this._doConnect(this.connectOptions.uris[this.hostIndex]);else if (void 0 === a && (a = g.OK.code, b = f(g.OK)), this.connected) {\n      if (this.connected = !1, this.onConnectionLost) this.onConnectionLost({ errorCode: a, errorMessage: b });\n    } else if (4 === this.connectOptions.mqttVersion && !1 === this.connectOptions.mqttVersionExplicit) this._trace("Failed to connect V4, dropping back to V3"), this.connectOptions.mqttVersion = 3, this.connectOptions.uris ? (this.hostIndex = 0, this._doConnect(this.connectOptions.uris[0])) : this._doConnect(this.uri);else if (this.connectOptions.onFailure) this.connectOptions.onFailure({ invocationContext: this.connectOptions.invocationContext, errorCode: a, errorMessage: b });\n  };k.prototype._trace = function () {\n    if (this.traceFunction) {\n      for (var a in arguments) {\n        "undefined" !== typeof arguments[a] && (arguments[a] = JSON.stringify(arguments[a]));\n      }a = Array.prototype.slice.call(arguments).join("");this.traceFunction({ severity: "Debug", message: a });\n    }if (null !== this._traceBuffer) {\n      a = 0;for (var b = arguments.length; a < b; a++) {\n        this._traceBuffer.length == this._MAX_TRACE_ENTRIES && this._traceBuffer.shift(), 0 === a ? this._traceBuffer.push(arguments[a]) : "undefined" === typeof arguments[a] ? this._traceBuffer.push(arguments[a]) : this._traceBuffer.push("  " + JSON.stringify(arguments[a]));\n      }\n    }\n  };k.prototype._traceMask = function (a, b) {\n    var c = {},\n        f;for (f in a) {\n      a.hasOwnProperty(f) && (c[f] = f == b ? "******" : a[f]);\n    }return c;\n  };var H = function H(a, b, c, h) {\n    var e;if ("string" !== typeof a) throw Error(f(g.INVALID_TYPE, [typeof a === "undefined" ? "undefined" : _typeof(a), "host"]));if (2 == arguments.length) {\n      h = b;e = a;var d = e.match(/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/);\n      if (d) a = d[4] || d[2], b = parseInt(d[7]), c = d[8];else throw Error(f(g.INVALID_ARGUMENT, [a, "host"]));\n    } else {\n      3 == arguments.length && (h = c, c = "/mqtt");if ("number" !== typeof b || 0 > b) throw Error(f(g.INVALID_TYPE, [typeof b === "undefined" ? "undefined" : _typeof(b), "port"]));if ("string" !== typeof c) throw Error(f(g.INVALID_TYPE, [typeof c === "undefined" ? "undefined" : _typeof(c), "path"]));e = "ws://" + (-1 != a.indexOf(":") && "[" != a.slice(0, 1) && "]" != a.slice(-1) ? "[" + a + "]" : a) + ":" + b + c;\n    }for (var p = d = 0; p < h.length; p++) {\n      var m = h.charCodeAt(p);55296 <= m && 56319 >= m && p++;d++;\n    }if ("string" !== typeof h || 65535 < d) throw Error(f(g.INVALID_ARGUMENT, [h, "clientId"]));var l = new k(e, a, b, c, h);this._getHost = function () {\n      return a;\n    };this._setHost = function () {\n      throw Error(f(g.UNSUPPORTED_OPERATION));\n    };this._getPort = function () {\n      return b;\n    };this._setPort = function () {\n      throw Error(f(g.UNSUPPORTED_OPERATION));\n    };this._getPath = function () {\n      return c;\n    };this._setPath = function () {\n      throw Error(f(g.UNSUPPORTED_OPERATION));\n    };this._getURI = function () {\n      return e;\n    };this._setURI = function () {\n      throw Error(f(g.UNSUPPORTED_OPERATION));\n    };this._getClientId = function () {\n      return l.clientId;\n    };this._setClientId = function () {\n      throw Error(f(g.UNSUPPORTED_OPERATION));\n    };this._getOnConnectionLost = function () {\n      return l.onConnectionLost;\n    };this._setOnConnectionLost = function (a) {\n      if ("function" === typeof a) l.onConnectionLost = a;else throw Error(f(g.INVALID_TYPE, [typeof a === "undefined" ? "undefined" : _typeof(a), "onConnectionLost"]));\n    };this._getOnMessageDelivered = function () {\n      return l.onMessageDelivered;\n    };this._setOnMessageDelivered = function (a) {\n      if ("function" === typeof a) l.onMessageDelivered = a;else throw Error(f(g.INVALID_TYPE, [typeof a === "undefined" ? "undefined" : _typeof(a), "onMessageDelivered"]));\n    };this._getOnMessageArrived = function () {\n      return l.onMessageArrived;\n    };this._setOnMessageArrived = function (a) {\n      if ("function" === typeof a) l.onMessageArrived = a;else throw Error(f(g.INVALID_TYPE, [typeof a === "undefined" ? "undefined" : _typeof(a), "onMessageArrived"]));\n    };this._getTrace = function () {\n      return l.traceFunction;\n    };this._setTrace = function (a) {\n      if ("function" === typeof a) l.traceFunction = a;else throw Error(f(g.INVALID_TYPE, [typeof a === "undefined" ? "undefined" : _typeof(a), "onTrace"]));\n    };this.connect = function (a) {\n      a = a || {};z(a, { timeout: "number", userName: "string", password: "string", willMessage: "object", keepAliveInterval: "number",\n        cleanSession: "boolean", useSSL: "boolean", invocationContext: "object", onSuccess: "function", onFailure: "function", hosts: "object", ports: "object", mqttVersion: "number", mqttVersionExplicit: "boolean", uris: "object" });void 0 === a.keepAliveInterval && (a.keepAliveInterval = 60);if (4 < a.mqttVersion || 3 > a.mqttVersion) throw Error(f(g.INVALID_ARGUMENT, [a.mqttVersion, "connectOptions.mqttVersion"]));void 0 === a.mqttVersion ? (a.mqttVersionExplicit = !1, a.mqttVersion = 4) : a.mqttVersionExplicit = !0;if (void 0 !== a.password && void 0 === a.userName) throw Error(f(g.INVALID_ARGUMENT, [a.password, "connectOptions.password"]));if (a.willMessage) {\n        if (!(a.willMessage instanceof w)) throw Error(f(g.INVALID_TYPE, [a.willMessage, "connectOptions.willMessage"]));a.willMessage.stringPayload;if ("undefined" === typeof a.willMessage.destinationName) throw Error(f(g.INVALID_TYPE, [_typeof(a.willMessage.destinationName), "connectOptions.willMessage.destinationName"]));\n      }"undefined" === typeof a.cleanSession && (a.cleanSession = !0);if (a.hosts) {\n        if (!(a.hosts instanceof Array)) throw Error(f(g.INVALID_ARGUMENT, [a.hosts, "connectOptions.hosts"]));if (1 > a.hosts.length) throw Error(f(g.INVALID_ARGUMENT, [a.hosts, "connectOptions.hosts"]));for (var b = !1, d = 0; d < a.hosts.length; d++) {\n          if ("string" !== typeof a.hosts[d]) throw Error(f(g.INVALID_TYPE, [_typeof(a.hosts[d]), "connectOptions.hosts[" + d + "]"]));if (/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(a.hosts[d])) {\n            if (0 == d) b = !0;else {\n              if (!b) throw Error(f(g.INVALID_ARGUMENT, [a.hosts[d], "connectOptions.hosts[" + d + "]"]));\n            }\n          } else if (b) throw Error(f(g.INVALID_ARGUMENT, [a.hosts[d], "connectOptions.hosts[" + d + "]"]));\n        }if (b) a.uris = a.hosts;else {\n          if (!a.ports) throw Error(f(g.INVALID_ARGUMENT, [a.ports, "connectOptions.ports"]));if (!(a.ports instanceof Array)) throw Error(f(g.INVALID_ARGUMENT, [a.ports, "connectOptions.ports"]));if (a.hosts.length != a.ports.length) throw Error(f(g.INVALID_ARGUMENT, [a.ports, "connectOptions.ports"]));a.uris = [];for (d = 0; d < a.hosts.length; d++) {\n            if ("number" !== typeof a.ports[d] || 0 > a.ports[d]) throw Error(f(g.INVALID_TYPE, [_typeof(a.ports[d]), "connectOptions.ports[" + d + "]"]));var b = a.hosts[d],\n                h = a.ports[d];e = "ws://" + (-1 != b.indexOf(":") ? "[" + b + "]" : b) + ":" + h + c;a.uris.push(e);\n          }\n        }\n      }l.connect(a);\n    };this.subscribe = function (a, b) {\n      if ("string" !== typeof a) throw Error("Invalid argument:" + a);b = b || {};z(b, { qos: "number", invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" });if (b.timeout && !b.onFailure) throw Error("subscribeOptions.timeout specified with no onFailure callback.");if ("undefined" !== typeof b.qos && 0 !== b.qos && 1 !== b.qos && 2 !== b.qos) throw Error(f(g.INVALID_ARGUMENT, [b.qos, "subscribeOptions.qos"]));l.subscribe(a, b);\n    };this.unsubscribe = function (a, b) {\n      if ("string" !== typeof a) throw Error("Invalid argument:" + a);b = b || {};z(b, { invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" });if (b.timeout && !b.onFailure) throw Error("unsubscribeOptions.timeout specified with no onFailure callback.");l.unsubscribe(a, b);\n    };this.send = function (a, b, c, d) {\n      var e;if (0 == arguments.length) throw Error("Invalid argument.length");if (1 == arguments.length) {\n        if (!(a instanceof w) && "string" !== typeof a) throw Error("Invalid argument:" + (typeof a === "undefined" ? "undefined" : _typeof(a)));e = a;if ("undefined" === typeof e.destinationName) throw Error(f(g.INVALID_ARGUMENT, [e.destinationName, "Message.destinationName"]));\n      } else e = new w(b), e.destinationName = a, 3 <= arguments.length && (e.qos = c), 4 <= arguments.length && (e.retained = d);l.send(e);\n    };this.disconnect = function () {\n      l.disconnect();\n    };this.getTraceLog = function () {\n      return l.getTraceLog();\n    };this.startTrace = function () {\n      l.startTrace();\n    };this.stopTrace = function () {\n      l.stopTrace();\n    };this.isConnected = function () {\n      return l.connected;\n    };\n  };H.prototype = { get host() {\n      return this._getHost();\n    }, set host(a) {\n      this._setHost(a);\n    }, get port() {\n      return this._getPort();\n    }, set port(a) {\n      this._setPort(a);\n    }, get path() {\n      return this._getPath();\n    }, set path(a) {\n      this._setPath(a);\n    }, get clientId() {\n      return this._getClientId();\n    }, set clientId(a) {\n      this._setClientId(a);\n    }, get onConnectionLost() {\n      return this._getOnConnectionLost();\n    }, set onConnectionLost(a) {\n      this._setOnConnectionLost(a);\n    }, get onMessageDelivered() {\n      return this._getOnMessageDelivered();\n    }, set onMessageDelivered(a) {\n      this._setOnMessageDelivered(a);\n    },\n    get onMessageArrived() {\n      return this._getOnMessageArrived();\n    }, set onMessageArrived(a) {\n      this._setOnMessageArrived(a);\n    }, get trace() {\n      return this._getTrace();\n    }, set trace(a) {\n      this._setTrace(a);\n    } };var w = function w(a) {\n    var b;if ("string" === typeof a || a instanceof ArrayBuffer || a instanceof Int8Array || a instanceof Uint8Array || a instanceof Int16Array || a instanceof Uint16Array || a instanceof Int32Array || a instanceof Uint32Array || a instanceof Float32Array || a instanceof Float64Array) b = a;else throw f(g.INVALID_ARGUMENT, [a, "newPayload"]);\n    this._getPayloadString = function () {\n      return "string" === typeof b ? b : F(b, 0, b.length);\n    };this._getPayloadBytes = function () {\n      if ("string" === typeof b) {\n        var a = new ArrayBuffer(m(b)),\n            a = new Uint8Array(a);E(b, a, 0);return a;\n      }return b;\n    };var c = void 0;this._getDestinationName = function () {\n      return c;\n    };this._setDestinationName = function (a) {\n      if ("string" === typeof a) c = a;else throw Error(f(g.INVALID_ARGUMENT, [a, "newDestinationName"]));\n    };var h = 0;this._getQos = function () {\n      return h;\n    };this._setQos = function (a) {\n      if (0 === a || 1 === a || 2 === a) h = a;else throw Error("Invalid argument:" + a);\n    };var e = !1;this._getRetained = function () {\n      return e;\n    };this._setRetained = function (a) {\n      if ("boolean" === typeof a) e = a;else throw Error(f(g.INVALID_ARGUMENT, [a, "newRetained"]));\n    };var d = !1;this._getDuplicate = function () {\n      return d;\n    };this._setDuplicate = function (a) {\n      d = a;\n    };\n  };w.prototype = { get payloadString() {\n      return this._getPayloadString();\n    }, get payloadBytes() {\n      return this._getPayloadBytes();\n    }, get destinationName() {\n      return this._getDestinationName();\n    }, set destinationName(a) {\n      this._setDestinationName(a);\n    }, get qos() {\n      return this._getQos();\n    },\n    set qos(a) {\n      this._setQos(a);\n    }, get retained() {\n      return this._getRetained();\n    }, set retained(a) {\n      this._setRetained(a);\n    }, get duplicate() {\n      return this._getDuplicate();\n    }, set duplicate(a) {\n      this._setDuplicate(a);\n    } };return { Client: H, Message: w };\n}(window);\n\n//# sourceURL=webpack:///./node_modules/paho-mqtt/mqttws31-min.js?')},"./node_modules/srcdoc-polyfill/srcdoc-polyfill.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n(function (root, factory) {\n\t// `root` does not resolve to the global window object in a Browserified\n\t// bundle, so a direct reference to that object is used instead.\n\tvar _srcDoc = window.srcDoc;\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (exports) {\n\t\t\tfactory(exports, _srcDoc);\n\t\t\troot.srcDoc = exports;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n})(this, function (exports, _srcDoc) {\n\tvar idx, iframes;\n\tvar isCompliant = !!("srcdoc" in document.createElement("iframe"));\n\tvar sandboxMsg = "Polyfill may not function in the presence of the " + "`sandbox` attribute. Consider using the `force` option.";\n\tvar sandboxAllow = /\\ballow-same-origin\\b/;\n\t/**\n  * Determine if the operation may be blocked by the `sandbox` attribute in\n  * some environments, and optionally issue a warning or remove the\n  * attribute.\n  */\n\tvar validate = function validate(iframe, options) {\n\t\tvar sandbox = iframe.getAttribute("sandbox");\n\t\tif (typeof sandbox === "string" && !sandboxAllow.test(sandbox)) {\n\t\t\tif (options && options.force) {\n\t\t\t\tiframe.removeAttribute("sandbox");\n\t\t\t} else if (!options || options.force !== false) {\n\t\t\t\tlogError(sandboxMsg);\n\t\t\t\tiframe.setAttribute("data-srcdoc-polyfill", sandboxMsg);\n\t\t\t}\n\t\t}\n\t};\n\tvar implementations = {\n\t\tcompliant: function compliant(iframe, content, options) {\n\n\t\t\tif (content) {\n\t\t\t\tvalidate(iframe, options);\n\t\t\t\tiframe.setAttribute("srcdoc", content);\n\t\t\t}\n\t\t},\n\t\tlegacy: function legacy(iframe, content, options) {\n\n\t\t\tvar jsUrl;\n\n\t\t\tif (!iframe || !iframe.getAttribute) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!content) {\n\t\t\t\tcontent = iframe.getAttribute("srcdoc");\n\t\t\t} else {\n\t\t\t\tiframe.setAttribute("srcdoc", content);\n\t\t\t}\n\n\t\t\tif (content) {\n\t\t\t\tvalidate(iframe, options);\n\n\t\t\t\t// The value returned by a script-targeted URL will be used as\n\t\t\t\t// the iFrame\'s content. Create such a URL which returns the\n\t\t\t\t// iFrame element\'s `srcdoc` attribute.\n\t\t\t\tjsUrl = "javascript: window.frameElement.getAttribute(\'srcdoc\');";\n\n\t\t\t\t// Explicitly set the iFrame\'s window.location for\n\t\t\t\t// compatability with IE9, which does not react to changes in\n\t\t\t\t// the `src` attribute when it is a `javascript:` URL, for\n\t\t\t\t// some reason\n\t\t\t\tif (iframe.contentWindow) {\n\t\t\t\t\tiframe.contentWindow.location = jsUrl;\n\t\t\t\t}\n\n\t\t\t\tiframe.setAttribute("src", jsUrl);\n\t\t\t}\n\t\t}\n\t};\n\tvar srcDoc = exports;\n\tvar logError;\n\n\tif (window.console && window.console.error) {\n\t\tlogError = function logError(msg) {\n\t\t\twindow.console.error("[srcdoc-polyfill] " + msg);\n\t\t};\n\t} else {\n\t\tlogError = function logError() {};\n\t}\n\n\t// Assume the best\n\tsrcDoc.set = implementations.compliant;\n\tsrcDoc.noConflict = function () {\n\t\twindow.srcDoc = _srcDoc;\n\t\treturn srcDoc;\n\t};\n\n\t// If the browser supports srcdoc, no shimming is necessary\n\tif (isCompliant) {\n\t\treturn;\n\t}\n\n\tsrcDoc.set = implementations.legacy;\n\n\t// Automatically shim any iframes already present in the document\n\tiframes = document.getElementsByTagName("iframe");\n\tidx = iframes.length;\n\n\twhile (idx--) {\n\t\tsrcDoc.set(iframes[idx]);\n\t}\n});\n\n//# sourceURL=webpack:///./node_modules/srcdoc-polyfill/srcdoc-polyfill.js?')},"./node_modules/uuid/lib/bytesToUuid.js":function(module,exports){eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/bytesToUuid.js?")},"./node_modules/uuid/lib/rng-browser.js":function(module,exports){eval("// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && msCrypto.getRandomValues.bind(msCrypto);\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/rng-browser.js?")},"./node_modules/uuid/v4.js":function(module,exports,__webpack_require__){eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n//# sourceURL=webpack:///./node_modules/uuid/v4.js?")},"./node_modules/videojs-errors/dist/videojs-errors.es.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! video.js */ \"video.js\");\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(video_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var global_document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! global/document */ \"./node_modules/global/document.js\");\n/* harmony import */ var global_document__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(global_document__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar FlashObj = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.getComponent('Flash');\nvar defaultDismiss = !video_js__WEBPACK_IMPORTED_MODULE_0___default.a.browser.IS_IPHONE;\n\n// Video.js 5/6 cross-compatibility.\nvar registerPlugin = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.registerPlugin || video_js__WEBPACK_IMPORTED_MODULE_0___default.a.plugin;\n\n// Default options for the plugin.\nvar defaults = {\n  header: '',\n  code: '',\n  message: '',\n  timeout: 45 * 1000,\n  dismiss: defaultDismiss,\n  progressDisabled: false,\n  errors: {\n    '1': {\n      type: 'MEDIA_ERR_ABORTED',\n      headline: 'The video download was cancelled'\n    },\n    '2': {\n      type: 'MEDIA_ERR_NETWORK',\n      headline: 'The video connection was lost, please confirm you are ' + 'connected to the internet'\n    },\n    '3': {\n      type: 'MEDIA_ERR_DECODE',\n      headline: 'The video is bad or in a format that cannot be played on your browser'\n    },\n    '4': {\n      type: 'MEDIA_ERR_SRC_NOT_SUPPORTED',\n      headline: 'This video is either unavailable or not supported in this browser'\n    },\n    '5': {\n      type: 'MEDIA_ERR_ENCRYPTED',\n      headline: 'The video you are trying to watch is encrypted and we do not know how ' + 'to decrypt it'\n    },\n    'unknown': {\n      type: 'MEDIA_ERR_UNKNOWN',\n      headline: 'An unanticipated problem was encountered, check back soon and try again'\n    },\n    '-1': {\n      type: 'PLAYER_ERR_NO_SRC',\n      headline: 'No video has been loaded'\n    },\n    '-2': {\n      type: 'PLAYER_ERR_TIMEOUT',\n      headline: 'Could not download the video'\n    },\n    'PLAYER_ERR_DOMAIN_RESTRICTED': {\n      headline: 'This video is restricted from playing on your current domain'\n    },\n    'PLAYER_ERR_IP_RESTRICTED': {\n      headline: 'This video is restricted at your current IP address'\n    },\n    'PLAYER_ERR_GEO_RESTRICTED': {\n      headline: 'This video is restricted from playing in your current geographic region'\n    },\n    'FLASHLS_ERR_CROSS_DOMAIN': {\n      headline: 'The video could not be loaded: crossdomain access denied.'\n    }\n  }\n};\n\nvar initPlugin = function initPlugin(player, options) {\n  var monitor = void 0;\n  var waiting = void 0;\n  var isStalling = void 0;\n  var listeners = [];\n\n  var updateErrors = function updateErrors(updates) {\n    options.errors = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(options.errors, updates);\n\n    // Create `code`s from errors which don't have them (based on their keys).\n    Object.keys(options.errors).forEach(function (k) {\n      var err = options.errors[k];\n\n      if (!err.type) {\n        err.type = k;\n      }\n    });\n  };\n\n  // Make sure we flesh out initially-provided errors.\n  updateErrors();\n\n  // clears the previous monitor timeout and sets up a new one\n  var resetMonitor = function resetMonitor() {\n    // at this point the player has recovered\n    player.clearTimeout(waiting);\n    if (isStalling) {\n      isStalling = false;\n      player.removeClass('vjs-waiting');\n    }\n\n    // start the loading spinner if player has stalled\n    waiting = player.setTimeout(function () {\n      // player already has an error\n      // or is not playing under normal conditions\n      if (player.error() || player.paused() || player.ended()) {\n        return;\n      }\n\n      isStalling = true;\n      player.addClass('vjs-waiting');\n    }, 1000);\n\n    player.clearTimeout(monitor);\n    monitor = player.setTimeout(function () {\n      // player already has an error\n      // or is not playing under normal conditions\n      if (player.error() || player.paused() || player.ended()) {\n        return;\n      }\n\n      player.error({\n        code: -2,\n        type: 'PLAYER_ERR_TIMEOUT'\n      });\n    }, options.timeout);\n\n    // clear out any existing player timeout\n    // playback has recovered\n    if (player.error() && player.error().code === -2) {\n      player.error(null);\n    }\n  };\n\n  // clear any previously registered listeners\n  var cleanup = function cleanup() {\n    var listener = void 0;\n\n    while (listeners.length) {\n      listener = listeners.shift();\n      player.off(listener[0], listener[1]);\n    }\n    player.clearTimeout(monitor);\n    player.clearTimeout(waiting);\n  };\n\n  // creates and tracks a player listener if the player looks alive\n  var healthcheck = function healthcheck(type, fn) {\n    var check = function check() {\n      // if there's an error do not reset the monitor and\n      // clear the error unless time is progressing\n      if (!player.error()) {\n        // error if using Flash and its API is unavailable\n        var tech = player.$('.vjs-tech');\n\n        if (tech && tech.type === 'application/x-shockwave-flash' && !tech.vjs_getProperty) {\n          player.error({\n            code: -2,\n            type: 'PLAYER_ERR_TIMEOUT'\n          });\n          return;\n        }\n\n        // playback isn't expected if the player is paused\n        if (player.paused()) {\n          return resetMonitor();\n        }\n        // playback isn't expected once the video has ended\n        if (player.ended()) {\n          return resetMonitor();\n        }\n      }\n\n      fn.call(this);\n    };\n\n    player.on(type, check);\n    listeners.push([type, check]);\n  };\n\n  var onPlayStartMonitor = function onPlayStartMonitor() {\n    var lastTime = 0;\n\n    cleanup();\n\n    // if no playback is detected for long enough, trigger a timeout error\n    resetMonitor();\n    healthcheck(['timeupdate', 'adtimeupdate'], function () {\n      var currentTime = player.currentTime();\n\n      // playback is operating normally or has recovered\n      if (currentTime !== lastTime) {\n        lastTime = currentTime;\n        resetMonitor();\n      }\n    });\n\n    if (!options.progressDisabled) {\n      healthcheck('progress', resetMonitor);\n    }\n  };\n\n  var onPlayNoSource = function onPlayNoSource() {\n    if (!player.currentSrc()) {\n      player.error({\n        code: -1,\n        type: 'PLAYER_ERR_NO_SRC'\n      });\n    }\n  };\n\n  var onErrorHandler = function onErrorHandler() {\n    var details = '';\n    var error = player.error();\n    var content = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('div');\n    var dialogContent = '';\n\n    // In the rare case when `error()` does not return an error object,\n    // defensively escape the handler function.\n    if (!error) {\n      return;\n    }\n\n    error = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(error, options.errors[error.code || error.type || 0]);\n\n    if (error.message) {\n      details = '<div class=\"vjs-errors-details\">' + player.localize('Technical details') + '\\n        : <div class=\"vjs-errors-message\">' + player.localize(error.message) + '</div>\\n        </div>';\n    }\n\n    if (error.code === 4 && FlashObj && !FlashObj.isSupported()) {\n      var flashMessage = player.localize('If you are using an older browser please try upgrading or installing Flash.');\n\n      details += '<span class=\"vjs-errors-flashmessage\">' + flashMessage + '</span>';\n    }\n\n    var display = player.getChild('errorDisplay');\n\n    content.className = 'vjs-errors-dialog';\n    content.id = 'vjs-errors-dialog';\n    dialogContent = '<div class=\"vjs-errors-content-container\">\\n      <h2 class=\"vjs-errors-headline\">' + this.localize(error.headline) + '</h2>\\n        <div><b>' + this.localize('Error Code') + '</b>: ' + (error.type || error.code) + '</div>\\n        ' + details + '\\n      </div>';\n\n    var closeable = display.closeable(!('dismiss' in error) || error.dismiss);\n\n    // We should get a close button\n    if (closeable) {\n      dialogContent += '<div class=\"vjs-errors-ok-button-container\">\\n          <button class=\"vjs-errors-ok-button\">' + this.localize('OK') + '</button>\\n        </div>';\n      content.innerHTML = dialogContent;\n      display.fillWith(content);\n      // Get the close button inside the error display\n      display.contentEl().firstChild.appendChild(display.getChild('closeButton').el());\n\n      var okButton = display.el().querySelector('.vjs-errors-ok-button');\n\n      player.on(okButton, 'click', function () {\n        display.close();\n      });\n    } else {\n      content.innerHTML = dialogContent;\n      display.fillWith(content);\n    }\n\n    if (player.currentWidth() <= 600 || player.currentHeight() <= 250) {\n      display.addClass('vjs-xs');\n    }\n\n    display.one('modalclose', function () {\n      return player.error(null);\n    });\n  };\n\n  var onDisposeHandler = function onDisposeHandler() {\n    cleanup();\n\n    player.removeClass('vjs-errors');\n    player.off('play', onPlayStartMonitor);\n    player.off('play', onPlayNoSource);\n    player.off('dispose', onDisposeHandler);\n    player.off(['aderror', 'error'], onErrorHandler);\n  };\n\n  var reInitPlugin = function reInitPlugin(newOptions) {\n    onDisposeHandler();\n    initPlugin(player, video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(defaults, newOptions));\n  };\n\n  reInitPlugin.extend = function (errors) {\n    return updateErrors(errors);\n  };\n  reInitPlugin.getAll = function () {\n    return video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(options.errors);\n  };\n\n  reInitPlugin.disableProgress = function (disabled) {\n    options.progressDisabled = disabled;\n    onPlayStartMonitor();\n  };\n\n  player.on('play', onPlayStartMonitor);\n  player.on('play', onPlayNoSource);\n  player.on('dispose', onDisposeHandler);\n  player.on(['aderror', 'error'], onErrorHandler);\n\n  player.ready(function () {\n    player.addClass('vjs-errors');\n  });\n\n  player.errors = reInitPlugin;\n};\n\nvar errors = function errors(options) {\n  initPlugin(this, video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(defaults, options));\n};\n\n['extend', 'getAll', 'disableProgress'].forEach(function (k) {\n  errors[k] = function () {\n    video_js__WEBPACK_IMPORTED_MODULE_0___default.a.log.warn('The errors.' + k + '() method is not available until the plugin has been initialized!');\n  };\n});\n\n// Register the plugin with video.js.\nregisterPlugin('errors', errors);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (errors);\n\n//# sourceURL=webpack:///./node_modules/videojs-errors/dist/videojs-errors.es.js?")},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1, eval)("this");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./package.json":function(module){eval('module.exports = {"name":"videojs-mse-over-clsp","version":"0.1.8","description":"Uses clsp (iot) as a video distribution system, video is is received via the clsp client then rendered using the media source extensions. ","main":"dist/videojs-mse-over-clsp.js","generator-videojs-plugin":{"version":"5.0.0"},"scripts":{"build":"gulp build","lint":"eslint ./ --cache --quiet --ext .jsx --ext .js","lint-fix":"eslint ./ --cache --quiet --ext .jsx --ext .js --fix","postversion":"git push && git push --tags","start-dev":"gulp start-dev"},"keywords":["videojs","videojs-plugin"],"author":"dschere@skylinenet.net","license":"MIT","dependencies":{"debug":"^3.1.0","paho-mqtt":"1.0.3","pre-commit":"^1.2.2","srcdoc-polyfill":"^1.0.0","videojs-errors":"^3.0.3"},"devDependencies":{"babel-core":"^6.26.0","babel-eslint":"^8.2.2","babel-loader":"^7.1.2","babel-plugin-transform-class-properties":"^6.24.1","babel-plugin-transform-object-rest-spread":"^6.26.0","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","css-loader":"^0.28.5","eslint":"^4.18.1","extract-text-webpack-plugin":"^4.0.0-beta.0","gulp":"^3.9.1","gulp-load-plugins":"^1.5.0","gulp-rm":"^1.0.5","js-string-escape":"^1.0.1","node-sass":"^4.5.3","run-sequence":"^2.2.0","sass-loader":"^6.0.6","standard":"^11.0.0","style-loader":"^0.20.2","uglifyjs-webpack-plugin":"^1.2.2","webpack":"^4.0.1","webpack-serve":"^0.1.5"}};\n\n//# sourceURL=webpack:///./package.json?')},"./src/js/MqttHandler.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! video.js */ "video.js");\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(video_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _iov_IOV__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iov/IOV */ "./src/js/iov/IOV.js");\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar Component = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.getComponent(\'Component\');\n\n/* harmony default export */ __webpack_exports__["default"] = (function (SrcsLookupTable) {\n    var MqttHandler = function (_Component) {\n        _inherits(MqttHandler, _Component);\n\n        function MqttHandler(source, tech, options) {\n            _classCallCheck(this, MqttHandler);\n\n            var _this = _possibleConstructorReturn(this, (MqttHandler.__proto__ || Object.getPrototypeOf(MqttHandler)).call(this, tech, options.mqtt));\n\n            _this.tech_ = tech;\n            _this.source_ = source;\n            _this.enabled = false;\n            _this.playing = false;\n            return _this;\n        }\n\n        _createClass(MqttHandler, [{\n            key: \'src\',\n            value: function src(_src) {\n                if (!_src) {\n                    return;\n                }\n                var parser = document.createElement(\'a\');\n\n                // firefox/ie hack!\n                var kluged_src = _src.replace(\'clsp\', \'http\');\n\n                parser.href = kluged_src;\n                //parser.href = "http:" + parser.pathname;\n\n                var hostname = parser.hostname;\n                var port = parser.port;\n                var t = parser.pathname.split("/");\n                var streamName = t[t.length - 1];\n\n                this.useSSL = false;\n\n                // clsp://.../name?[secure=1]\n                parser.search.substr(1).split(\'&\').forEach(function (item) {\n                    var t = item.split(\'=\');\n                    var n = t[0];\n                    var v = t[1];\n                    if (n === \'secure\' && v !== \'0\') {\n                        useSSL = true;\n                    }\n                });\n\n                if (port.length === 0) {\n                    port = "9001";\n                }\n\n                // @ is a special address maening the server that loaded the web page.\n                if (hostname === \'@\') {\n                    hostname = window.location.hostname;\n                }\n\n                this.mqtt_player = null;\n                this.port = parseInt(port);\n                this.address = hostname;\n                this.streamName = streamName;\n                this.enabled = true;\n\n                SrcsLookupTable[_src] = this;\n            }\n        }, {\n            key: \'launchIovPlayer\',\n            value: function launchIovPlayer(onMqttReady) {\n                var _this2 = this;\n\n                var velm = this.player().el();\n\n                var iov = new _iov_IOV__WEBPACK_IMPORTED_MODULE_1__["default"]({\n                    port: this.port,\n                    address: this.address,\n                    appStart: function appStart(iov) {\n                        // connected to MQTT procede to setting up callbacks\n                        //console.log("iov.player() called")\n                        var mqtt_player = iov.player();\n                        var evt = new CustomEvent("mqttReady");\n                        _this2.player().el().dispatchEvent(evt);\n                        onMqttReady(mqtt_player);\n\n                        velm.addEventListener("mse-error-event", function (e) {\n                            mqtt_player.restart();\n                        }, false);\n                    },\n                    useSSL: this.useSSL,\n                    videoElement: velm\n                });\n\n                iov.initialize();\n            }\n        }]);\n\n        return MqttHandler;\n    }(Component);\n\n    ;\n\n    return MqttHandler;\n});\n\n//# sourceURL=webpack:///./src/js/MqttHandler.js?')},"./src/js/MqttSourceHandler.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! video.js */ "video.js");\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(video_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/js/utils.js");\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (function (MqttHandler) {\n    /*\n       source handler for the source tag in html5:\n       <video><source src="..." type="..."></video>\n        mqttSourceHandler = {\n           canPlayType: function(type) {\n               // only the canned type for MediaSource entensions\n               // use media source extensions to determine if\n               // it can play it. MQTT/video\n           },\n           canHandleSource: function(source, options) {\n               // check for mqtt:// .... as a protocol\n           },\n           handleSource : function(source, tech, options) {\n           },\n           dispose: function() {\n               // destructor.\n           }\n       }\n        Html5 = videojs.getTech(\'Html5\');\n       Html5.registerSourceHandler(mqttSourceHandler);\n     */\n\n    var MqttSourceHandler = function MqttSourceHandler(mode) {\n        var obj = {\n            canPlayType: function canPlayType(type) {\n                var r = \'\';\n                if (\'MediaSource\' in window) {\n                    if (type === "video/mp4; codecs=\'avc1.42E01E\'") {\n                        r = \'maybe\';\n                    } else {\n                        console.log("clsp type=\'" + type + "\' rejected");\n                    }\n                }\n                return r;\n            },\n            canHandleSource: function canHandleSource(srcObj) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n                /* This method is used to determin if the following html5 tag can be used\n                   as a video source:\n                    <source src="clsp://<ip addr>:<ws port>/<mqtt topic>"\n                           type="video/mp4; codecs=\'avc1.42E01E\'" />\n                */\n                var localOptions = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(video_js__WEBPACK_IMPORTED_MODULE_0___default.a.options, options);\n\n                if (!srcObj.src) {\n                    console.log("srcObj doesn\'t contain src");\n                    console.log(srcObj);\n                    return false;\n                }\n\n                if (srcObj.src.startsWith("clsp:") === false) {\n                    console.log("srcObj.src is not clsp protocol");\n                    return false;\n                }\n\n                /// restrict to chrome version 52 or greater\n                if (_utils__WEBPACK_IMPORTED_MODULE_1__["default"].supported() === false) {\n                    console.log("Browser not supported. Chrome 52+ is required.");\n                    return false;\n                }\n\n                return obj.canPlayType(srcObj.type);\n            },\n            handleSource: function handleSource(srcObj, tech) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n                var localOptions = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(video_js__WEBPACK_IMPORTED_MODULE_0___default.a.options, options, { mqtt: { mode: mode } });\n\n                tech.mqtt = new MqttHandler(srcObj, tech, localOptions);\n                tech.mqtt.src(srcObj.src);\n                return tech.mqtt;\n            }\n        };\n        return obj;\n    };\n\n    return MqttSourceHandler;\n});\n\n//# sourceURL=webpack:///./src/js/MqttSourceHandler.js?')},"./src/js/conduit/clspConduit.generated.js":function(module,exports){eval('/*\nCreates a hidden iframe that is used to establish a dedicated mqtt websocket\nfor a single video. This is basically an in browser micro service which\nuses cross document communication to route data to and from the iframe.\n*/\n\n// The below string literals allow the iframe to be created completely withinjavascript allowing\n// the videojs to be completely protable.\n\n\n// this code is filled in by the gulpfile.js\nvar iframe_code = "/*******************************************************************************\\n * Copyright (c) 2013, 2014 IBM Corp.\\n *\\n * All rights reserved. This program and the accompanying materials\\n * are made available under the terms of the Eclipse Public License v1.0\\n * and Eclipse Distribution License v1.0 which accompany this distribution. \\n *\\n * The Eclipse Public License is available at \\n *    http://www.eclipse.org/legal/epl-v10.html\\n * and the Eclipse Distribution License is available at \\n *   http://www.eclipse.org/org/documents/edl-v10.php.\\n *\\n *******************************************************************************/\\n\\n\\"undefined\\"===typeof Paho&&(Paho={});\\nPaho.MQTT=function(t){function x(a,b,c){b[c++]=a>>8;b[c++]=a%256;return c}function r(a,b,c,h){h=x(b,c,h);E(a,c,h);return h+b}function m(a){for(var b=0,c=0;c<a.length;c++){var h=a.charCodeAt(c);2047<h?(55296<=h&&56319>=h&&(c++,b++),b+=3):127<h?b+=2:b++}return b}function E(a,b,c){for(var h=0;h<a.length;h++){var e=a.charCodeAt(h);if(55296<=e&&56319>=e){var d=a.charCodeAt(++h);if(isNaN(d))throw Error(f(g.MALFORMED_UNICODE,[e,d]));e=(e-55296<<10)+(d-56320)+65536}127>=e?b[c++]=e:(2047>=e?b[c++]=e>>6&31|\\n192:(65535>=e?b[c++]=e>>12&15|224:(b[c++]=e>>18&7|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b}function F(a,b,c){for(var h=\\"\\",e,d=b;d<b+c;){e=a[d++];if(!(128>e)){var p=a[d++]-128;if(0>p)throw Error(f(g.MALFORMED_UTF,[e.toString(16),p.toString(16),\\"\\"]));if(224>e)e=64*(e-192)+p;else{var s=a[d++]-128;if(0>s)throw Error(f(g.MALFORMED_UTF,[e.toString(16),p.toString(16),s.toString(16)]));if(240>e)e=4096*(e-224)+64*p+s;else{var l=a[d++]-128;if(0>l)throw Error(f(g.MALFORMED_UTF,\\n[e.toString(16),p.toString(16),s.toString(16),l.toString(16)]));if(248>e)e=262144*(e-240)+4096*p+64*s+l;else throw Error(f(g.MALFORMED_UTF,[e.toString(16),p.toString(16),s.toString(16),l.toString(16)]));}}}65535<e&&(e-=65536,h+=String.fromCharCode(55296+(e>>10)),e=56320+(e&1023));h+=String.fromCharCode(e)}return h}var z=function(a,b){for(var c in a)if(a.hasOwnProperty(c))if(b.hasOwnProperty(c)){if(typeof a[c]!==b[c])throw Error(f(g.INVALID_TYPE,[typeof a[c],c]));}else{var h=\\"Unknown property, \\"+c+\\n\\". Valid properties are:\\";for(c in b)b.hasOwnProperty(c)&&(h=h+\\" \\"+c);throw Error(h);}},q=function(a,b){return function(){return a.apply(b,arguments)}},g={OK:{code:0,text:\\"AMQJSC0000I OK.\\"},CONNECT_TIMEOUT:{code:1,text:\\"AMQJSC0001E Connect timed out.\\"},SUBSCRIBE_TIMEOUT:{code:2,text:\\"AMQJS0002E Subscribe timed out.\\"},UNSUBSCRIBE_TIMEOUT:{code:3,text:\\"AMQJS0003E Unsubscribe timed out.\\"},PING_TIMEOUT:{code:4,text:\\"AMQJS0004E Ping timed out.\\"},INTERNAL_ERROR:{code:5,text:\\"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}\\"},\\nCONNACK_RETURNCODE:{code:6,text:\\"AMQJS0006E Bad Connack return code:{0} {1}.\\"},SOCKET_ERROR:{code:7,text:\\"AMQJS0007E Socket error:{0}.\\"},SOCKET_CLOSE:{code:8,text:\\"AMQJS0008I Socket closed.\\"},MALFORMED_UTF:{code:9,text:\\"AMQJS0009E Malformed UTF data:{0} {1} {2}.\\"},UNSUPPORTED:{code:10,text:\\"AMQJS0010E {0} is not supported by this browser.\\"},INVALID_STATE:{code:11,text:\\"AMQJS0011E Invalid state {0}.\\"},INVALID_TYPE:{code:12,text:\\"AMQJS0012E Invalid type {0} for {1}.\\"},INVALID_ARGUMENT:{code:13,text:\\"AMQJS0013E Invalid argument {0} for {1}.\\"},\\nUNSUPPORTED_OPERATION:{code:14,text:\\"AMQJS0014E Unsupported operation.\\"},INVALID_STORED_DATA:{code:15,text:\\"AMQJS0015E Invalid data in local storage key\\\\x3d{0} value\\\\x3d{1}.\\"},INVALID_MQTT_MESSAGE_TYPE:{code:16,text:\\"AMQJS0016E Invalid MQTT message type {0}.\\"},MALFORMED_UNICODE:{code:17,text:\\"AMQJS0017E Malformed Unicode string:{0} {1}.\\"}},I={0:\\"Connection Accepted\\",1:\\"Connection Refused: unacceptable protocol version\\",2:\\"Connection Refused: identifier rejected\\",3:\\"Connection Refused: server unavailable\\",\\n4:\\"Connection Refused: bad user name or password\\",5:\\"Connection Refused: not authorized\\"},f=function(a,b){var c=a.text;if(b)for(var h,e,d=0;d<b.length;d++)if(h=\\"{\\"+d+\\"}\\",e=c.indexOf(h),0<e)var g=c.substring(0,e),c=c.substring(e+h.length),c=g+b[d]+c;return c},A=[0,6,77,81,73,115,100,112,3],B=[0,4,77,81,84,84,4],n=function(a,b){this.type=a;for(var c in b)b.hasOwnProperty(c)&&(this[c]=b[c])};n.prototype.encode=function(){var a=(this.type&15)<<4,b=0,c=[],h=0;void 0!=this.messageIdentifier&&(b+=2);switch(this.type){case 1:switch(this.mqttVersion){case 3:b+=\\nA.length+3;break;case 4:b+=B.length+3}b+=m(this.clientId)+2;if(void 0!=this.willMessage){var b=b+(m(this.willMessage.destinationName)+2),e=this.willMessage.payloadBytes;e instanceof Uint8Array||(e=new Uint8Array(g));b+=e.byteLength+2}void 0!=this.userName&&(b+=m(this.userName)+2);void 0!=this.password&&(b+=m(this.password)+2);break;case 8:for(var a=a|2,d=0;d<this.topics.length;d++)c[d]=m(this.topics[d]),b+=c[d]+2;b+=this.requestedQos.length;break;case 10:a|=2;for(d=0;d<this.topics.length;d++)c[d]=\\nm(this.topics[d]),b+=c[d]+2;break;case 6:a|=2;break;case 3:this.payloadMessage.duplicate&&(a|=8);a=a|=this.payloadMessage.qos<<1;this.payloadMessage.retained&&(a|=1);var h=m(this.payloadMessage.destinationName),g=this.payloadMessage.payloadBytes,b=b+(h+2)+g.byteLength;g instanceof ArrayBuffer?g=new Uint8Array(g):g instanceof Uint8Array||(g=new Uint8Array(g.buffer))}var f=b,d=Array(1),l=0;do{var y=f%128,f=f>>7;0<f&&(y|=128);d[l++]=y}while(0<f&&4>l);f=d.length+1;b=new ArrayBuffer(b+f);l=new Uint8Array(b);\\nl[0]=a;l.set(d,1);if(3==this.type)f=r(this.payloadMessage.destinationName,h,l,f);else if(1==this.type){switch(this.mqttVersion){case 3:l.set(A,f);f+=A.length;break;case 4:l.set(B,f),f+=B.length}a=0;this.cleanSession&&(a=2);void 0!=this.willMessage&&(a=a|4|this.willMessage.qos<<3,this.willMessage.retained&&(a|=32));void 0!=this.userName&&(a|=128);void 0!=this.password&&(a|=64);l[f++]=a;f=x(this.keepAliveInterval,l,f)}void 0!=this.messageIdentifier&&(f=x(this.messageIdentifier,l,f));switch(this.type){case 1:f=\\nr(this.clientId,m(this.clientId),l,f);void 0!=this.willMessage&&(f=r(this.willMessage.destinationName,m(this.willMessage.destinationName),l,f),f=x(e.byteLength,l,f),l.set(e,f),f+=e.byteLength);void 0!=this.userName&&(f=r(this.userName,m(this.userName),l,f));void 0!=this.password&&r(this.password,m(this.password),l,f);break;case 3:l.set(g,f);break;case 8:for(d=0;d<this.topics.length;d++)f=r(this.topics[d],c[d],l,f),l[f++]=this.requestedQos[d];break;case 10:for(d=0;d<this.topics.length;d++)f=r(this.topics[d],\\nc[d],l,f)}return b};var G=function(a,b,c){this._client=a;this._window=b;this._keepAliveInterval=1E3*c;this.isReset=!1;var h=(new n(12)).encode(),e=function(a){return function(){return d.apply(a)}},d=function(){this.isReset?(this.isReset=!1,this._client._trace(\\"Pinger.doPing\\",\\"send PINGREQ\\"),this._client.socket.send(h),this.timeout=this._window.setTimeout(e(this),this._keepAliveInterval)):(this._client._trace(\\"Pinger.doPing\\",\\"Timed out\\"),this._client._disconnected(g.PING_TIMEOUT.code,f(g.PING_TIMEOUT)))};\\nthis.reset=function(){this.isReset=!0;this._window.clearTimeout(this.timeout);0<this._keepAliveInterval&&(this.timeout=setTimeout(e(this),this._keepAliveInterval))};this.cancel=function(){this._window.clearTimeout(this.timeout)}},C=function(a,b,c,f,e){this._window=b;c||(c=30);this.timeout=setTimeout(function(a,b,c){return function(){return a.apply(b,c)}}(f,a,e),1E3*c);this.cancel=function(){this._window.clearTimeout(this.timeout)}},k=function(a,b,c,h,e){if(!(\\"WebSocket\\"in t&&null!==t.WebSocket))throw Error(f(g.UNSUPPORTED,\\n[\\"WebSocket\\"]));if(!(\\"localStorage\\"in t&&null!==t.localStorage))throw Error(f(g.UNSUPPORTED,[\\"localStorage\\"]));if(!(\\"ArrayBuffer\\"in t&&null!==t.ArrayBuffer))throw Error(f(g.UNSUPPORTED,[\\"ArrayBuffer\\"]));this._trace(\\"Paho.MQTT.Client\\",a,b,c,h,e);this.host=b;this.port=c;this.path=h;this.uri=a;this.clientId=e;this._localKey=b+\\":\\"+c+(\\"/mqtt\\"!=h?\\":\\"+h:\\"\\")+\\":\\"+e+\\":\\";this._msg_queue=[];this._sentMessages={};this._receivedMessages={};this._notify_msg_sent={};this._message_identifier=1;this._sequence=0;for(var d in localStorage)0!=\\nd.indexOf(\\"Sent:\\"+this._localKey)&&0!=d.indexOf(\\"Received:\\"+this._localKey)||this.restore(d)};k.prototype.host;k.prototype.port;k.prototype.path;k.prototype.uri;k.prototype.clientId;k.prototype.socket;k.prototype.connected=!1;k.prototype.maxMessageIdentifier=65536;k.prototype.connectOptions;k.prototype.hostIndex;k.prototype.onConnectionLost;k.prototype.onMessageDelivered;k.prototype.onMessageArrived;k.prototype.traceFunction;k.prototype._msg_queue=null;k.prototype._connectTimeout;k.prototype.sendPinger=\\nnull;k.prototype.receivePinger=null;k.prototype.receiveBuffer=null;k.prototype._traceBuffer=null;k.prototype._MAX_TRACE_ENTRIES=100;k.prototype.connect=function(a){var b=this._traceMask(a,\\"password\\");this._trace(\\"Client.connect\\",b,this.socket,this.connected);if(this.connected)throw Error(f(g.INVALID_STATE,[\\"already connected\\"]));if(this.socket)throw Error(f(g.INVALID_STATE,[\\"already connected\\"]));this.connectOptions=a;a.uris?(this.hostIndex=0,this._doConnect(a.uris[0])):this._doConnect(this.uri)};\\nk.prototype.subscribe=function(a,b){this._trace(\\"Client.subscribe\\",a,b);if(!this.connected)throw Error(f(g.INVALID_STATE,[\\"not connected\\"]));var c=new n(8);c.topics=[a];c.requestedQos=void 0!=b.qos?[b.qos]:[0];b.onSuccess&&(c.onSuccess=function(a){b.onSuccess({invocationContext:b.invocationContext,grantedQos:a})});b.onFailure&&(c.onFailure=function(a){b.onFailure({invocationContext:b.invocationContext,errorCode:a})});b.timeout&&(c.timeOut=new C(this,window,b.timeout,b.onFailure,[{invocationContext:b.invocationContext,\\nerrorCode:g.SUBSCRIBE_TIMEOUT.code,errorMessage:f(g.SUBSCRIBE_TIMEOUT)}]));this._requires_ack(c);this._schedule_message(c)};k.prototype.unsubscribe=function(a,b){this._trace(\\"Client.unsubscribe\\",a,b);if(!this.connected)throw Error(f(g.INVALID_STATE,[\\"not connected\\"]));var c=new n(10);c.topics=[a];b.onSuccess&&(c.callback=function(){b.onSuccess({invocationContext:b.invocationContext})});b.timeout&&(c.timeOut=new C(this,window,b.timeout,b.onFailure,[{invocationContext:b.invocationContext,errorCode:g.UNSUBSCRIBE_TIMEOUT.code,\\nerrorMessage:f(g.UNSUBSCRIBE_TIMEOUT)}]));this._requires_ack(c);this._schedule_message(c)};k.prototype.send=function(a){this._trace(\\"Client.send\\",a);if(!this.connected)throw Error(f(g.INVALID_STATE,[\\"not connected\\"]));wireMessage=new n(3);wireMessage.payloadMessage=a;0<a.qos?this._requires_ack(wireMessage):this.onMessageDelivered&&(this._notify_msg_sent[wireMessage]=this.onMessageDelivered(wireMessage.payloadMessage));this._schedule_message(wireMessage)};k.prototype.disconnect=function(){this._trace(\\"Client.disconnect\\");\\nif(!this.socket)throw Error(f(g.INVALID_STATE,[\\"not connecting or connected\\"]));wireMessage=new n(14);this._notify_msg_sent[wireMessage]=q(this._disconnected,this);this._schedule_message(wireMessage)};k.prototype.getTraceLog=function(){if(null!==this._traceBuffer){this._trace(\\"Client.getTraceLog\\",new Date);this._trace(\\"Client.getTraceLog in flight messages\\",this._sentMessages.length);for(var a in this._sentMessages)this._trace(\\"_sentMessages \\",a,this._sentMessages[a]);for(a in this._receivedMessages)this._trace(\\"_receivedMessages \\",\\na,this._receivedMessages[a]);return this._traceBuffer}};k.prototype.startTrace=function(){null===this._traceBuffer&&(this._traceBuffer=[]);this._trace(\\"Client.startTrace\\",new Date,\\"1.0.2\\")};k.prototype.stopTrace=function(){delete this._traceBuffer};k.prototype._doConnect=function(a){this.connectOptions.useSSL&&(a=a.split(\\":\\"),a[0]=\\"wss\\",a=a.join(\\":\\"));this.connected=!1;this.socket=4>this.connectOptions.mqttVersion?new WebSocket(a,[\\"mqttv3.1\\"]):new WebSocket(a,[\\"mqtt\\"]);this.socket.binaryType=\\n\\"arraybuffer\\";this.socket.onopen=q(this._on_socket_open,this);this.socket.onmessage=q(this._on_socket_message,this);this.socket.onerror=q(this._on_socket_error,this);this.socket.onclose=q(this._on_socket_close,this);this.sendPinger=new G(this,window,this.connectOptions.keepAliveInterval);this.receivePinger=new G(this,window,this.connectOptions.keepAliveInterval);this._connectTimeout=new C(this,window,this.connectOptions.timeout,this._disconnected,[g.CONNECT_TIMEOUT.code,f(g.CONNECT_TIMEOUT)])};k.prototype._schedule_message=\\nfunction(a){this._msg_queue.push(a);this.connected&&this._process_queue()};k.prototype.store=function(a,b){var c={type:b.type,messageIdentifier:b.messageIdentifier,version:1};switch(b.type){case 3:b.pubRecReceived&&(c.pubRecReceived=!0);c.payloadMessage={};for(var h=\\"\\",e=b.payloadMessage.payloadBytes,d=0;d<e.length;d++)h=15>=e[d]?h+\\"0\\"+e[d].toString(16):h+e[d].toString(16);c.payloadMessage.payloadHex=h;c.payloadMessage.qos=b.payloadMessage.qos;c.payloadMessage.destinationName=b.payloadMessage.destinationName;\\nb.payloadMessage.duplicate&&(c.payloadMessage.duplicate=!0);b.payloadMessage.retained&&(c.payloadMessage.retained=!0);0==a.indexOf(\\"Sent:\\")&&(void 0===b.sequence&&(b.sequence=++this._sequence),c.sequence=b.sequence);break;default:throw Error(f(g.INVALID_STORED_DATA,[key,c]));}localStorage.setItem(a+this._localKey+b.messageIdentifier,JSON.stringify(c))};k.prototype.restore=function(a){var b=localStorage.getItem(a),c=JSON.parse(b),h=new n(c.type,c);switch(c.type){case 3:for(var b=c.payloadMessage.payloadHex,\\ne=new ArrayBuffer(b.length/2),e=new Uint8Array(e),d=0;2<=b.length;){var k=parseInt(b.substring(0,2),16),b=b.substring(2,b.length);e[d++]=k}b=new Paho.MQTT.Message(e);b.qos=c.payloadMessage.qos;b.destinationName=c.payloadMessage.destinationName;c.payloadMessage.duplicate&&(b.duplicate=!0);c.payloadMessage.retained&&(b.retained=!0);h.payloadMessage=b;break;default:throw Error(f(g.INVALID_STORED_DATA,[a,b]));}0==a.indexOf(\\"Sent:\\"+this._localKey)?(h.payloadMessage.duplicate=!0,this._sentMessages[h.messageIdentifier]=\\nh):0==a.indexOf(\\"Received:\\"+this._localKey)&&(this._receivedMessages[h.messageIdentifier]=h)};k.prototype._process_queue=function(){for(var a=null,b=this._msg_queue.reverse();a=b.pop();)this._socket_send(a),this._notify_msg_sent[a]&&(this._notify_msg_sent[a](),delete this._notify_msg_sent[a])};k.prototype._requires_ack=function(a){var b=Object.keys(this._sentMessages).length;if(b>this.maxMessageIdentifier)throw Error(\\"Too many messages:\\"+b);for(;void 0!==this._sentMessages[this._message_identifier];)this._message_identifier++;\\na.messageIdentifier=this._message_identifier;this._sentMessages[a.messageIdentifier]=a;3===a.type&&this.store(\\"Sent:\\",a);this._message_identifier===this.maxMessageIdentifier&&(this._message_identifier=1)};k.prototype._on_socket_open=function(){var a=new n(1,this.connectOptions);a.clientId=this.clientId;this._socket_send(a)};k.prototype._on_socket_message=function(a){this._trace(\\"Client._on_socket_message\\",a.data);a=this._deframeMessages(a.data);for(var b=0;b<a.length;b+=1)this._handleMessage(a[b])};\\nk.prototype._deframeMessages=function(a){a=new Uint8Array(a);if(this.receiveBuffer){var b=new Uint8Array(this.receiveBuffer.length+a.length);b.set(this.receiveBuffer);b.set(a,this.receiveBuffer.length);a=b;delete this.receiveBuffer}try{for(var b=0,c=[];b<a.length;){var h;a:{var e=a,d=b,k=d,s=e[d],l=s>>4,y=s&15,d=d+1,u=void 0,D=0,m=1;do{if(d==e.length){h=[null,k];break a}u=e[d++];D+=(u&127)*m;m*=128}while(0!=(u&128));u=d+D;if(u>e.length)h=[null,k];else{var v=new n(l);switch(l){case 2:e[d++]&1&&(v.sessionPresent=\\n!0);v.returnCode=e[d++];break;case 3:var k=y>>1&3,r=256*e[d]+e[d+1],d=d+2,t=F(e,d,r),d=d+r;0<k&&(v.messageIdentifier=256*e[d]+e[d+1],d+=2);var q=new Paho.MQTT.Message(e.subarray(d,u));1==(y&1)&&(q.retained=!0);8==(y&8)&&(q.duplicate=!0);q.qos=k;q.destinationName=t;v.payloadMessage=q;break;case 4:case 5:case 6:case 7:case 11:v.messageIdentifier=256*e[d]+e[d+1];break;case 9:v.messageIdentifier=256*e[d]+e[d+1],d+=2,v.returnCode=e.subarray(d,u)}h=[v,u]}}var w=h[0],b=h[1];if(null!==w)c.push(w);else break}b<\\na.length&&(this.receiveBuffer=a.subarray(b))}catch(x){this._disconnected(g.INTERNAL_ERROR.code,f(g.INTERNAL_ERROR,[x.message,x.stack.toString()]));return}return c};k.prototype._handleMessage=function(a){this._trace(\\"Client._handleMessage\\",a);try{switch(a.type){case 2:this._connectTimeout.cancel();if(this.connectOptions.cleanSession){for(var b in this._sentMessages){var c=this._sentMessages[b];localStorage.removeItem(\\"Sent:\\"+this._localKey+c.messageIdentifier)}this._sentMessages={};for(b in this._receivedMessages){var h=\\nthis._receivedMessages[b];localStorage.removeItem(\\"Received:\\"+this._localKey+h.messageIdentifier)}this._receivedMessages={}}if(0===a.returnCode)this.connected=!0,this.connectOptions.uris&&(this.hostIndex=this.connectOptions.uris.length);else{this._disconnected(g.CONNACK_RETURNCODE.code,f(g.CONNACK_RETURNCODE,[a.returnCode,I[a.returnCode]]));break}a=[];for(var e in this._sentMessages)this._sentMessages.hasOwnProperty(e)&&a.push(this._sentMessages[e]);a=a.sort(function(a,b){return a.sequence-b.sequence});\\ne=0;for(var d=a.length;e<d;e++)if(c=a[e],3==c.type&&c.pubRecReceived){var k=new n(6,{messageIdentifier:c.messageIdentifier});this._schedule_message(k)}else this._schedule_message(c);if(this.connectOptions.onSuccess)this.connectOptions.onSuccess({invocationContext:this.connectOptions.invocationContext});this._process_queue();break;case 3:this._receivePublish(a);break;case 4:if(c=this._sentMessages[a.messageIdentifier])if(delete this._sentMessages[a.messageIdentifier],localStorage.removeItem(\\"Sent:\\"+\\nthis._localKey+a.messageIdentifier),this.onMessageDelivered)this.onMessageDelivered(c.payloadMessage);break;case 5:if(c=this._sentMessages[a.messageIdentifier])c.pubRecReceived=!0,k=new n(6,{messageIdentifier:a.messageIdentifier}),this.store(\\"Sent:\\",c),this._schedule_message(k);break;case 6:h=this._receivedMessages[a.messageIdentifier];localStorage.removeItem(\\"Received:\\"+this._localKey+a.messageIdentifier);h&&(this._receiveMessage(h),delete this._receivedMessages[a.messageIdentifier]);var m=new n(7,\\n{messageIdentifier:a.messageIdentifier});this._schedule_message(m);break;case 7:c=this._sentMessages[a.messageIdentifier];delete this._sentMessages[a.messageIdentifier];localStorage.removeItem(\\"Sent:\\"+this._localKey+a.messageIdentifier);if(this.onMessageDelivered)this.onMessageDelivered(c.payloadMessage);break;case 9:if(c=this._sentMessages[a.messageIdentifier]){c.timeOut&&c.timeOut.cancel();if(128===a.returnCode[0]){if(c.onFailure)c.onFailure(a.returnCode)}else if(c.onSuccess)c.onSuccess(a.returnCode);\\ndelete this._sentMessages[a.messageIdentifier]}break;case 11:if(c=this._sentMessages[a.messageIdentifier])c.timeOut&&c.timeOut.cancel(),c.callback&&c.callback(),delete this._sentMessages[a.messageIdentifier];break;case 13:this.sendPinger.reset();break;case 14:this._disconnected(g.INVALID_MQTT_MESSAGE_TYPE.code,f(g.INVALID_MQTT_MESSAGE_TYPE,[a.type]));break;default:this._disconnected(g.INVALID_MQTT_MESSAGE_TYPE.code,f(g.INVALID_MQTT_MESSAGE_TYPE,[a.type]))}}catch(l){this._disconnected(g.INTERNAL_ERROR.code,\\nf(g.INTERNAL_ERROR,[l.message,l.stack.toString()]))}};k.prototype._on_socket_error=function(a){this._disconnected(g.SOCKET_ERROR.code,f(g.SOCKET_ERROR,[a.data]))};k.prototype._on_socket_close=function(){this._disconnected(g.SOCKET_CLOSE.code,f(g.SOCKET_CLOSE))};k.prototype._socket_send=function(a){if(1==a.type){var b=this._traceMask(a,\\"password\\");this._trace(\\"Client._socket_send\\",b)}else this._trace(\\"Client._socket_send\\",a);this.socket.send(a.encode());this.sendPinger.reset()};k.prototype._receivePublish=\\nfunction(a){switch(a.payloadMessage.qos){case \\"undefined\\":case 0:this._receiveMessage(a);break;case 1:var b=new n(4,{messageIdentifier:a.messageIdentifier});this._schedule_message(b);this._receiveMessage(a);break;case 2:this._receivedMessages[a.messageIdentifier]=a;this.store(\\"Received:\\",a);a=new n(5,{messageIdentifier:a.messageIdentifier});this._schedule_message(a);break;default:throw Error(\\"Invaild qos\\\\x3d\\"+wireMmessage.payloadMessage.qos);}};k.prototype._receiveMessage=function(a){if(this.onMessageArrived)this.onMessageArrived(a.payloadMessage)};\\nk.prototype._disconnected=function(a,b){this._trace(\\"Client._disconnected\\",a,b);this.sendPinger.cancel();this.receivePinger.cancel();this._connectTimeout&&this._connectTimeout.cancel();this._msg_queue=[];this._notify_msg_sent={};this.socket&&(this.socket.onopen=null,this.socket.onmessage=null,this.socket.onerror=null,this.socket.onclose=null,1===this.socket.readyState&&this.socket.close(),delete this.socket);if(this.connectOptions.uris&&this.hostIndex<this.connectOptions.uris.length-1)this.hostIndex++,\\nthis._doConnect(this.connectOptions.uris[this.hostIndex]);else if(void 0===a&&(a=g.OK.code,b=f(g.OK)),this.connected){if(this.connected=!1,this.onConnectionLost)this.onConnectionLost({errorCode:a,errorMessage:b})}else if(4===this.connectOptions.mqttVersion&&!1===this.connectOptions.mqttVersionExplicit)this._trace(\\"Failed to connect V4, dropping back to V3\\"),this.connectOptions.mqttVersion=3,this.connectOptions.uris?(this.hostIndex=0,this._doConnect(this.connectOptions.uris[0])):this._doConnect(this.uri);\\nelse if(this.connectOptions.onFailure)this.connectOptions.onFailure({invocationContext:this.connectOptions.invocationContext,errorCode:a,errorMessage:b})};k.prototype._trace=function(){if(this.traceFunction){for(var a in arguments)\\"undefined\\"!==typeof arguments[a]&&(arguments[a]=JSON.stringify(arguments[a]));a=Array.prototype.slice.call(arguments).join(\\"\\");this.traceFunction({severity:\\"Debug\\",message:a})}if(null!==this._traceBuffer){a=0;for(var b=arguments.length;a<b;a++)this._traceBuffer.length==\\nthis._MAX_TRACE_ENTRIES&&this._traceBuffer.shift(),0===a?this._traceBuffer.push(arguments[a]):\\"undefined\\"===typeof arguments[a]?this._traceBuffer.push(arguments[a]):this._traceBuffer.push(\\"  \\"+JSON.stringify(arguments[a]))}};k.prototype._traceMask=function(a,b){var c={},f;for(f in a)a.hasOwnProperty(f)&&(c[f]=f==b?\\"******\\":a[f]);return c};var H=function(a,b,c,h){var e;if(\\"string\\"!==typeof a)throw Error(f(g.INVALID_TYPE,[typeof a,\\"host\\"]));if(2==arguments.length){h=b;e=a;var d=e.match(/^(wss?):\\\\/\\\\/((\\\\[(.+)\\\\])|([^\\\\/]+?))(:(\\\\d+))?(\\\\/.*)$/);\\nif(d)a=d[4]||d[2],b=parseInt(d[7]),c=d[8];else throw Error(f(g.INVALID_ARGUMENT,[a,\\"host\\"]));}else{3==arguments.length&&(h=c,c=\\"/mqtt\\");if(\\"number\\"!==typeof b||0>b)throw Error(f(g.INVALID_TYPE,[typeof b,\\"port\\"]));if(\\"string\\"!==typeof c)throw Error(f(g.INVALID_TYPE,[typeof c,\\"path\\"]));e=\\"ws://\\"+(-1!=a.indexOf(\\":\\")&&\\"[\\"!=a.slice(0,1)&&\\"]\\"!=a.slice(-1)?\\"[\\"+a+\\"]\\":a)+\\":\\"+b+c}for(var p=d=0;p<h.length;p++){var m=h.charCodeAt(p);55296<=m&&56319>=m&&p++;d++}if(\\"string\\"!==typeof h||65535<d)throw Error(f(g.INVALID_ARGUMENT,\\n[h,\\"clientId\\"]));var l=new k(e,a,b,c,h);this._getHost=function(){return a};this._setHost=function(){throw Error(f(g.UNSUPPORTED_OPERATION));};this._getPort=function(){return b};this._setPort=function(){throw Error(f(g.UNSUPPORTED_OPERATION));};this._getPath=function(){return c};this._setPath=function(){throw Error(f(g.UNSUPPORTED_OPERATION));};this._getURI=function(){return e};this._setURI=function(){throw Error(f(g.UNSUPPORTED_OPERATION));};this._getClientId=function(){return l.clientId};this._setClientId=\\nfunction(){throw Error(f(g.UNSUPPORTED_OPERATION));};this._getOnConnectionLost=function(){return l.onConnectionLost};this._setOnConnectionLost=function(a){if(\\"function\\"===typeof a)l.onConnectionLost=a;else throw Error(f(g.INVALID_TYPE,[typeof a,\\"onConnectionLost\\"]));};this._getOnMessageDelivered=function(){return l.onMessageDelivered};this._setOnMessageDelivered=function(a){if(\\"function\\"===typeof a)l.onMessageDelivered=a;else throw Error(f(g.INVALID_TYPE,[typeof a,\\"onMessageDelivered\\"]));};this._getOnMessageArrived=\\nfunction(){return l.onMessageArrived};this._setOnMessageArrived=function(a){if(\\"function\\"===typeof a)l.onMessageArrived=a;else throw Error(f(g.INVALID_TYPE,[typeof a,\\"onMessageArrived\\"]));};this._getTrace=function(){return l.traceFunction};this._setTrace=function(a){if(\\"function\\"===typeof a)l.traceFunction=a;else throw Error(f(g.INVALID_TYPE,[typeof a,\\"onTrace\\"]));};this.connect=function(a){a=a||{};z(a,{timeout:\\"number\\",userName:\\"string\\",password:\\"string\\",willMessage:\\"object\\",keepAliveInterval:\\"number\\",\\ncleanSession:\\"boolean\\",useSSL:\\"boolean\\",invocationContext:\\"object\\",onSuccess:\\"function\\",onFailure:\\"function\\",hosts:\\"object\\",ports:\\"object\\",mqttVersion:\\"number\\",mqttVersionExplicit:\\"boolean\\",uris:\\"object\\"});void 0===a.keepAliveInterval&&(a.keepAliveInterval=60);if(4<a.mqttVersion||3>a.mqttVersion)throw Error(f(g.INVALID_ARGUMENT,[a.mqttVersion,\\"connectOptions.mqttVersion\\"]));void 0===a.mqttVersion?(a.mqttVersionExplicit=!1,a.mqttVersion=4):a.mqttVersionExplicit=!0;if(void 0!==a.password&&void 0===\\na.userName)throw Error(f(g.INVALID_ARGUMENT,[a.password,\\"connectOptions.password\\"]));if(a.willMessage){if(!(a.willMessage instanceof w))throw Error(f(g.INVALID_TYPE,[a.willMessage,\\"connectOptions.willMessage\\"]));a.willMessage.stringPayload;if(\\"undefined\\"===typeof a.willMessage.destinationName)throw Error(f(g.INVALID_TYPE,[typeof a.willMessage.destinationName,\\"connectOptions.willMessage.destinationName\\"]));}\\"undefined\\"===typeof a.cleanSession&&(a.cleanSession=!0);if(a.hosts){if(!(a.hosts instanceof\\nArray))throw Error(f(g.INVALID_ARGUMENT,[a.hosts,\\"connectOptions.hosts\\"]));if(1>a.hosts.length)throw Error(f(g.INVALID_ARGUMENT,[a.hosts,\\"connectOptions.hosts\\"]));for(var b=!1,d=0;d<a.hosts.length;d++){if(\\"string\\"!==typeof a.hosts[d])throw Error(f(g.INVALID_TYPE,[typeof a.hosts[d],\\"connectOptions.hosts[\\"+d+\\"]\\"]));if(/^(wss?):\\\\/\\\\/((\\\\[(.+)\\\\])|([^\\\\/]+?))(:(\\\\d+))?(\\\\/.*)$/.test(a.hosts[d]))if(0==d)b=!0;else{if(!b)throw Error(f(g.INVALID_ARGUMENT,[a.hosts[d],\\"connectOptions.hosts[\\"+d+\\"]\\"]));}else if(b)throw Error(f(g.INVALID_ARGUMENT,\\n[a.hosts[d],\\"connectOptions.hosts[\\"+d+\\"]\\"]));}if(b)a.uris=a.hosts;else{if(!a.ports)throw Error(f(g.INVALID_ARGUMENT,[a.ports,\\"connectOptions.ports\\"]));if(!(a.ports instanceof Array))throw Error(f(g.INVALID_ARGUMENT,[a.ports,\\"connectOptions.ports\\"]));if(a.hosts.length!=a.ports.length)throw Error(f(g.INVALID_ARGUMENT,[a.ports,\\"connectOptions.ports\\"]));a.uris=[];for(d=0;d<a.hosts.length;d++){if(\\"number\\"!==typeof a.ports[d]||0>a.ports[d])throw Error(f(g.INVALID_TYPE,[typeof a.ports[d],\\"connectOptions.ports[\\"+\\nd+\\"]\\"]));var b=a.hosts[d],h=a.ports[d];e=\\"ws://\\"+(-1!=b.indexOf(\\":\\")?\\"[\\"+b+\\"]\\":b)+\\":\\"+h+c;a.uris.push(e)}}}l.connect(a)};this.subscribe=function(a,b){if(\\"string\\"!==typeof a)throw Error(\\"Invalid argument:\\"+a);b=b||{};z(b,{qos:\\"number\\",invocationContext:\\"object\\",onSuccess:\\"function\\",onFailure:\\"function\\",timeout:\\"number\\"});if(b.timeout&&!b.onFailure)throw Error(\\"subscribeOptions.timeout specified with no onFailure callback.\\");if(\\"undefined\\"!==typeof b.qos&&0!==b.qos&&1!==b.qos&&2!==b.qos)throw Error(f(g.INVALID_ARGUMENT,\\n[b.qos,\\"subscribeOptions.qos\\"]));l.subscribe(a,b)};this.unsubscribe=function(a,b){if(\\"string\\"!==typeof a)throw Error(\\"Invalid argument:\\"+a);b=b||{};z(b,{invocationContext:\\"object\\",onSuccess:\\"function\\",onFailure:\\"function\\",timeout:\\"number\\"});if(b.timeout&&!b.onFailure)throw Error(\\"unsubscribeOptions.timeout specified with no onFailure callback.\\");l.unsubscribe(a,b)};this.send=function(a,b,c,d){var e;if(0==arguments.length)throw Error(\\"Invalid argument.length\\");if(1==arguments.length){if(!(a instanceof\\nw)&&\\"string\\"!==typeof a)throw Error(\\"Invalid argument:\\"+typeof a);e=a;if(\\"undefined\\"===typeof e.destinationName)throw Error(f(g.INVALID_ARGUMENT,[e.destinationName,\\"Message.destinationName\\"]));}else e=new w(b),e.destinationName=a,3<=arguments.length&&(e.qos=c),4<=arguments.length&&(e.retained=d);l.send(e)};this.disconnect=function(){l.disconnect()};this.getTraceLog=function(){return l.getTraceLog()};this.startTrace=function(){l.startTrace()};this.stopTrace=function(){l.stopTrace()};this.isConnected=\\nfunction(){return l.connected}};H.prototype={get host(){return this._getHost()},set host(a){this._setHost(a)},get port(){return this._getPort()},set port(a){this._setPort(a)},get path(){return this._getPath()},set path(a){this._setPath(a)},get clientId(){return this._getClientId()},set clientId(a){this._setClientId(a)},get onConnectionLost(){return this._getOnConnectionLost()},set onConnectionLost(a){this._setOnConnectionLost(a)},get onMessageDelivered(){return this._getOnMessageDelivered()},set onMessageDelivered(a){this._setOnMessageDelivered(a)},\\nget onMessageArrived(){return this._getOnMessageArrived()},set onMessageArrived(a){this._setOnMessageArrived(a)},get trace(){return this._getTrace()},set trace(a){this._setTrace(a)}};var w=function(a){var b;if(\\"string\\"===typeof a||a instanceof ArrayBuffer||a instanceof Int8Array||a instanceof Uint8Array||a instanceof Int16Array||a instanceof Uint16Array||a instanceof Int32Array||a instanceof Uint32Array||a instanceof Float32Array||a instanceof Float64Array)b=a;else throw f(g.INVALID_ARGUMENT,[a,\\"newPayload\\"]);\\nthis._getPayloadString=function(){return\\"string\\"===typeof b?b:F(b,0,b.length)};this._getPayloadBytes=function(){if(\\"string\\"===typeof b){var a=new ArrayBuffer(m(b)),a=new Uint8Array(a);E(b,a,0);return a}return b};var c=void 0;this._getDestinationName=function(){return c};this._setDestinationName=function(a){if(\\"string\\"===typeof a)c=a;else throw Error(f(g.INVALID_ARGUMENT,[a,\\"newDestinationName\\"]));};var h=0;this._getQos=function(){return h};this._setQos=function(a){if(0===a||1===a||2===a)h=a;else throw Error(\\"Invalid argument:\\"+\\na);};var e=!1;this._getRetained=function(){return e};this._setRetained=function(a){if(\\"boolean\\"===typeof a)e=a;else throw Error(f(g.INVALID_ARGUMENT,[a,\\"newRetained\\"]));};var d=!1;this._getDuplicate=function(){return d};this._setDuplicate=function(a){d=a}};w.prototype={get payloadString(){return this._getPayloadString()},get payloadBytes(){return this._getPayloadBytes()},get destinationName(){return this._getDestinationName()},set destinationName(a){this._setDestinationName(a)},get qos(){return this._getQos()},\\nset qos(a){this._setQos(a)},get retained(){return this._getRetained()},set retained(a){this._setRetained(a)},get duplicate(){return this._getDuplicate()},set duplicate(a){this._setDuplicate(a)}};return{Client:H,Message:w}}(window);\\nfunction _clspRouter() {\\n    function send(m){\\n        // route message to parent which will in turn route to the correct\\n        // player based on clientId.\\n        m.clientId = MqttClientId;\\n        // console.log(m);\\n        window.parent.postMessage(m,\\"*\\");\\n    }// end send\\n\\n\\n    function routeInbound(message){\\n        var pstring = \\"\\";\\n\\n        try {\\n            pstring = message.payloadString;\\n        } catch(e) {\\n            //bogus excepton?\\n        }\\n\\n        send({\\n          event: \\\'data\\\',\\n          destinationName: message.destinationName,\\n          payloadString: pstring,\\n          payloadBytes: message.payloadBytes || null\\n        });\\n    }// end route inbound\\n\\n\\n    function eventHandler(evt){\\n        var m = evt.data;\\n\\n        try {\\n            if (m.method === \\\'subscribe\\\') {\\n                MQTTClient.subscribe(m.topic);\\n            } else if (m.method === \\\'unsubscribe\\\') {\\n                MQTTClient.unsubscribe(m.topic);\\n            } else if (m.method === \\\'publish\\\') {\\n                var mqtt_payload = null;\\n                try {\\n                    mqtt_payload = JSON.stringify(m.data);\\n                } catch( json_error ) {\\n                    console.log(\\"json stringify error: \\" + m.data);\\n                    return;\\n                }\\n\\n                var mqtt_msg = new Paho.MQTT.Message(mqtt_payload);\\n                mqtt_msg.destinationName = m.topic;\\n                MQTTClient.send(mqtt_msg);\\n            }\\n        } catch(e) {\\n            console.log(\\"mqtt fatal error\\");\\n            console.log(e);\\n            // we are dead!\\n            MQTTClient.disconnect();\\n        }\\n    }\\n\\n    function AppReady() {\\n        if (window.addEventListener) {\\n            window.addEventListener(\\"message\\", eventHandler, false);\\n        } else if (window.attachEvent) {\\n            window.attachEvent(\\\'onmessage\\\', eventHandler);\\n        }\\n\\n        send({\\n          event: \\\'ready\\\'\\n        });\\n    }// application ready\\n\\n\\n    function AppFail(message) {\\n      var e = \\"Error code \\" +\\n          parseInt(message.errorCode) + \\": \\" + message.errorMessage;\\n      send({\\n        event: \\\'fail\\\',\\n        reason: e\\n      });\\n    }\\n\\n    MQTTClient = new Paho.MQTT.Client(\\n        MqttIp,\\n        MqttPort,\\n        MqttClientId\\n    );\\n\\n    // perhaps the busiest function in this module ;)\\n    MQTTClient.onMessageArrived = function(message) {\\n        //// console.log(message);\\n        try {\\n             routeInbound(message);\\n        }catch(e) {\\n            if (e) {\\n                // console.log(\\"Exception\\");\\n                console.log(e);\\n            }\\n        }\\n    };\\n\\n    // setup connection options\\n    var options = {\\n        timeout: 60,\\n        onSuccess:  AppReady,\\n        onFailure: AppFail\\n    };\\n    // last will message sent on disconnect\\n    var willmsg = new Paho.MQTT.Message(JSON.stringify({\\n        clientId: MqttClientId\\n    }));\\n    willmsg.destinationName = \\"iov/clientDisconnect\\";\\n    options.willMessage = willmsg;\\n\\n    if (MqttUseSSL === true) {\\n        options.useSSL = true;\\n    }\\n\\n\\n    MQTTClient.connect(options);\\n}\\n\\nfunction clspRouter() {\\n    try {\\n        _clspRouter();\\n    } catch(e) {\\n        console.log(\\"IFRAME error\\");\\n        console.log(e);\\n    }\\n}\\n\\nfunction onunload()\\n{\\n    if (typeof MQTTClient !== \\\'undefined\\\') {\\n        MQTTClient.disconnect();\\n    }\\n}\\n";\n\nfunction pframe_client(iframe, config, onReady) {\n    var self = {\n        dispatch: {}\n    };\n\n    // primitive function that routes message to iframe\n    function command(m) {\n\n        if (iframe.contentWindow !== null) {\n            iframe.contentWindow.postMessage(m, "*");\n            return;\n        }\n\n        var t = setInterval(function () {\n            if (iframe.contentWindow !== null) {\n                iframe.contentWindow.postMessage(m, "*");\n                clearInterval(t);\n            }\n        }, 1000);\n    }\n\n    // called when mqtt has connected\n    self.onReady = onReady;\n\n    /* message from mqttRouter routeInbound go handler which associates this\n       client with the clientId. It then calls self.inboundHandler handler to\n       process the message from the iframe.\n    */\n    self.inboundHandler = function (message) {\n        var handler = self.dispatch[message.destinationName];\n        if (typeof handler !== \'undefined\') {\n            try {\n                handler(message);\n            } catch (e) {\n                console.log(e);\n            }\n        } else {\n            console.log("No handler for " + message.destinationName);\n        }\n    };\n\n    self.subscribe = function (topic, callback) {\n        self.dispatch[topic] = callback;\n        command({\n            method: "subscribe",\n            topic: topic\n        });\n    };\n\n    self.unsubscribe = function (topic) {\n        if (topic in self.dispatch) {\n            delete self.dispatch[topic];\n        }\n        command({\n            method: "unsubscribe",\n            topic: topic\n        });\n    };\n\n    self.publish = function (topic, data) {\n        command({\n            method: "publish",\n            topic: topic,\n            data: data\n        });\n    };\n\n    self.transaction = function (topic, callback, obj) {\n        obj.resp_topic = config.clientId + "/response/" + parseInt(Math.random() * 1000000);\n        self.subscribe(obj.resp_topic, function (mqtt_resp) {\n            //call user specified callback to handle response from remote process\n            var resp = JSON.parse(mqtt_resp.payloadString);\n            // call user specified callback to handle response\n            callback(resp);\n            // cleanup.\n            self.unsubscribe(obj.resp_topic);\n        });\n\n        // start transaction\n        //MQTTClient.send(mqtt_msg);\n        self.publish(topic, obj);\n    };\n\n    // return client for video player.\n    return self;\n}\n\nwindow.mqttConduit = function (config, onReady) {\n    /*\n        config = {\n            ip: ... mqtt ip address\n            port: websocket port\n        }\n      }\n    */\n    var client = {};\n    var iframe = document.createElement(\'iframe\');\n    var MqttUseSSL = config.useSSL || false ? "true" : "false";\n\n    var markup = \'<html><head>\' + \'<script>\\n\' + "var MqttIp = \'" + config.wsbroker + "\' ; \\n" + "var MqttPort = " + config.wsport + "; \\n" + "var MqttUseSSL = " + MqttUseSSL + "; \\n" + "var MqttClientId = \'" + config.clientId + "\' ; \\n" + "var Origin = \'" + window.location.origin + "\' ; \\n" + iframe_code + \'\\n\' + \'<\/script>\\n\' + \'</head><body onload="clspRouter();" onunload="onunload();"><body>\' + \'<div id="message"></div>\' + \'</body></html>\';\n\n    // inject code into iframe\n    if (typeof iframe.srcdoc !== \'undefined\') {\n        iframe.srcdoc = markup;\n    } else {\n        window.srcDoc(iframe, markup);\n    }\n\n    iframe.width = 0;\n    iframe.height = 0;\n    iframe.setAttribute(\'style\', \'display:none;\');\n    iframe.setAttribute(\'id\', config.clientId);\n\n    // attach hidden iframe to player\n    //document.body.appendChild(iframe);\n    if (config.videoElement.parentNode !== null) {\n        config.videoElement.parentNode.appendChild(iframe);\n    } else {\n        var t = setInterval(function () {\n            if (config.videoElement.parentNode !== null) {\n                config.videoElement.parentNode.appendChild(iframe);\n                clearInterval(t);\n            }\n        }, 1000);\n    }\n\n    return pframe_client(iframe, config, onReady);\n};\n\n//# sourceURL=webpack:///./src/js/conduit/clspConduit.generated.js?')},"./src/js/iov/IOV.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js");\n/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uuid_v4__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _MqttTopicHandlers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MqttTopicHandlers */ "./src/js/iov/MqttTopicHandlers.js");\n/* harmony import */ var _MqttConduitCollection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MqttConduitCollection */ "./src/js/iov/MqttConduitCollection.js");\n/* harmony import */ var _MqttTransport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MqttTransport */ "./src/js/iov/MqttTransport.js");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./player */ "./src/js/iov/player.js");\n/* harmony import */ var paho_mqtt__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! paho-mqtt */ "./node_modules/paho-mqtt/mqttws31-min.js");\n/* harmony import */ var paho_mqtt__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(paho_mqtt__WEBPACK_IMPORTED_MODULE_6__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n\n\n\n\n\n\n\n\n\n\nvar DEBUG_PREFIX = \'clsp:iov\';\n\n/**\n * Internet of Video client. This module uses the MediaSource API to\n * deliver video content streamed through MQTT from distributed sources.\n */\n\nvar IOV = function () {\n  _createClass(IOV, null, [{\n    key: \'compatibilityCheck\',\n    value: function compatibilityCheck() {\n      // For the MAC\n      var NoMediaSourceAlert = false;\n\n      window.MediaSource = window.MediaSource || window.WebKitMediaSource;\n\n      if (!window.MediaSource) {\n        if (NoMediaSourceAlert === false) {\n          alert("Media Source Extensions not supported in your browser" + ": Claris Live Streaming will not work!");\n        }\n\n        NoMediaSourceAlert = true;\n      }\n    }\n  }]);\n\n  function IOV(config) {\n    _classCallCheck(this, IOV);\n\n    this.id = uuid_v4__WEBPACK_IMPORTED_MODULE_1___default()();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_0___default()(DEBUG_PREFIX + \':\' + this.id + \':main\');\n\n    this.config = {\n      // web socket address defaults to the address of the server that loaded this page.\n      wsbroker: config.address,\n      // default port number\n      wsport: config.port,\n      // default clientId\n      clientId: this.id,\n      // to be overriden by user.\n      appStart: config.appStart,\n      useSSL: config.useSSL || false,\n      videoElement: config.videoElement\n    };\n\n    // handle inbound messages from MQTT, including video\n    // and distributes them to players.\n    this.mqttTopicHandlers = new _MqttTopicHandlers__WEBPACK_IMPORTED_MODULE_2__["default"](this.id, this);\n    this.mqttConduitCollection = new _MqttConduitCollection__WEBPACK_IMPORTED_MODULE_3__["default"](this.id);\n    this.transport = new _MqttTransport__WEBPACK_IMPORTED_MODULE_4__["default"](this.id, this);\n\n    this.events = {\n      connection_lost: function connection_lost(responseObject) {\n        //TODO close all players and display an error message\n        console.log("MQTT connection lost");\n        console.log(responseObject);\n      },\n\n      on_message: this.mqttTopicHandlers.msghandler,\n\n      // generic exception handler\n      exception: function exception(text, e) {\n        console.log(text);\n        if (typeof e !== \'undefined\') {\n          console.log(e.stack);\n        }\n      }\n    };\n  }\n\n  _createClass(IOV, [{\n    key: \'initialize\',\n    value: function initialize() {\n      var _this = this;\n\n      IOV.compatibilityCheck();\n\n      // route inbound data from a frame running mqtt to the appropriate player\n      window.addEventListener(\'message\', function (event) {\n        _this.debug(\'message received\', event.data);\n\n        var clientId = event.data.clientId;\n\n        if (!_this.mqttConduitCollection.exists(clientId)) {\n          return;\n        }\n\n        var conduit = _this.mqttConduitCollection.getById(clientId);\n        var eventType = event.data.event;\n\n        switch (eventType) {\n          case \'data\':\n            conduit.inboundHandler(event.data);\n            break;\n          case \'ready\':\n            conduit.onReady();\n            break;\n          case \'fail\':\n            console.error(\'network error\', event.reason);\n            break;\n          default:\n            console.log("No match for event = " + eventType);\n        }\n      });\n    }\n  }, {\n    key: \'player\',\n    value: function player() {\n      return Object(_player__WEBPACK_IMPORTED_MODULE_5__["default"])(this);\n    }\n\n    // query remote server and get a list of all stream names\n\n  }, {\n    key: \'getAvailableStreams\',\n    value: function getAvailableStreams(callback) {\n      this.transport.transaction(\'iov/video/list\', callback, {});\n    }\n  }]);\n\n  return IOV;\n}();\n\n/* harmony default export */ __webpack_exports__["default"] = (IOV);\n\n//# sourceURL=webpack:///./src/js/iov/IOV.js?')},"./src/js/iov/MqttConduitCollection.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar DEBUG_PREFIX = 'clsp:iov';\n\nvar MqttConduitCollection = function () {\n  function MqttConduitCollection(id) {\n    _classCallCheck(this, MqttConduitCollection);\n\n    this.id = id;\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_0___default()(DEBUG_PREFIX + ':' + this.id + ':MqttConduitCollection');\n\n    this.debug('constructing...');\n\n    this._conduits = {};\n  }\n\n  _createClass(MqttConduitCollection, [{\n    key: 'set',\n    value: function set(id, conduit) {\n      this.debug('setting...', id, conduit);\n\n      this._conduits[id] = conduit;\n\n      return conduit;\n    }\n  }, {\n    key: 'addFromIov',\n    value: function addFromIov(transport, iov) {\n      var _this = this;\n\n      this.debug('adding from iov...', iov);\n\n      return this.set(iov.config.clientId, mqttConduit(iov.config, function () {\n        _this.debug('onReady...', iov.config.clientId);\n\n        iov.config.appStart(iov);\n\n        // the mse service will stop streaming to us if we don't send\n        // a message to iov/stats within 1 minute.\n        iov._statsTimer = setInterval(function () {\n          iov.statsMsg.inkbps = iov.statsMsg.byteCount * 8 / 30000.0;\n          iov.statsMsg.byteCount = 0;\n\n          transport.publish('iov/stats', iov.statsMsg);\n\n          _this.debug('iov status', iov.statsMsg);\n        }, 5000);\n      }));\n    }\n  }, {\n    key: 'getById',\n    value: function getById(id) {\n      this.debug('getting...', id);\n\n      return this._conduits[id];\n    }\n  }, {\n    key: 'exists',\n    value: function exists(id) {\n      this.debug('exists?', id);\n\n      return this._conduits.hasOwnProperty(id);\n    }\n  }]);\n\n  return MqttConduitCollection;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MqttConduitCollection);\n\n//# sourceURL=webpack:///./src/js/iov/MqttConduitCollection.js?")},"./src/js/iov/MqttTopicHandlers.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar DEBUG_PREFIX = 'clsp:iov';\n\n/**\n * route inbound messages/data to player's event handlers.\n */\n\nvar MqttTopicHandlers = function () {\n  function MqttTopicHandlers(id, iov) {\n    _classCallCheck(this, MqttTopicHandlers);\n\n    this.id = id;\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_0___default()(DEBUG_PREFIX + ':' + this.id + ':MqttTopicHandlers');\n\n    this.debug('constructing...');\n\n    this.iov = iov;\n    this._handlers = {};\n  }\n\n  _createClass(MqttTopicHandlers, [{\n    key: 'get',\n    value: function get(topic) {\n      this.debug('getting...', topic);\n\n      return this._handlers[topic];\n    }\n  }, {\n    key: 'register',\n    value: function register(topic, callback) {\n      var _this = this;\n\n      this.debug('register...', topic);\n\n      this._handlers[topic] = function () {\n        _this.debug('executing handler...', topic);\n\n        callback.apply(undefined, arguments);\n      };\n    }\n  }, {\n    key: 'unregister',\n    value: function unregister(topic) {\n      this.debug('unregistering...', topic);\n\n      if (this.exists(topic)) {\n        delete this._handlers[topic];\n      }\n    }\n  }, {\n    key: 'exists',\n    value: function exists(topic) {\n      this.debug('exists?', topic);\n\n      return this._handlers.hasOwnProperty(topic);\n    }\n\n    // central entry point for all MQTT inbound traffic.\n\n  }, {\n    key: 'msghandler',\n    value: function msghandler(message) {\n      this.debug('msghandler...', message);\n\n      var topic = message.destinationName;\n\n      if (!this.exists(topic)) {\n        debug('No handler for ' + topic + ' - message dropped', message);\n\n        return;\n      }\n\n      try {\n        this.get(topic)(message);\n      } catch (e) {\n        this.iov.events.exception(topic + ' handler exception', e);\n      }\n    }\n  }]);\n\n  return MqttTopicHandlers;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MqttTopicHandlers);\n\n//# sourceURL=webpack:///./src/js/iov/MqttTopicHandlers.js?")},"./src/js/iov/MqttTransport.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar DEBUG_PREFIX = 'clsp:iov';\n\nvar MqttTransport = function () {\n  function MqttTransport(id, iov) {\n    _classCallCheck(this, MqttTransport);\n\n    this.id = id;\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_0___default()(DEBUG_PREFIX + ':' + this.id + ':MqttConduitCollection');\n\n    this.debug('constructing...');\n\n    // setup stats\n    iov.statsMsg = {\n      byteCount: 0,\n      inkbps: 0,\n      host: document.location.host,\n      clientId: iov.config.clientId\n    };\n\n    this.clientId = iov.config.clientId;\n    this.iov = iov;\n\n    this.conduit = iov.mqttConduitCollection.addFromIov(this, iov);\n  }\n\n  // create a temporary resp_topic to receive a query response\n  // upon response remove the temporary topic. Assume both request\n  // and response are json formateed text.\n\n\n  _createClass(MqttTransport, [{\n    key: 'transaction',\n    value: function transaction(topic, callback, data) {\n      var _this = this;\n\n      this.debug('transaction...');\n\n      this.conduit.transaction(topic, function (event) {\n        _this.debug('transaction callback...', event);\n        if (callback) {\n          callback(event);\n        }\n      }, data);\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe(topic, callback) {\n      var _this2 = this;\n\n      this.debug('subscribe...');\n\n      this.conduit.subscribe(topic, function (event) {\n        _this2.debug('subscribe callback...', event);\n        if (callback) {\n          callback(event);\n        }\n      });\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe(topic, callback) {\n      var _this3 = this;\n\n      this.debug('unsubscribe...');\n\n      this.conduit.unsubscribe(topic, function (event) {\n        _this3.debug('unsubscribe callback...', event);\n        if (callback) {\n          callback(event);\n        }\n      });\n    }\n  }, {\n    key: 'publish',\n    value: function publish(topic, data, callback) {\n      var _this4 = this;\n\n      this.debug('publish...');\n\n      this.conduit.publish(topic, data, function (event) {\n        _this4.debug('publish callback...', event);\n        if (callback) {\n          callback(event);\n        }\n      });\n    }\n  }]);\n\n  return MqttTransport;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MqttTransport);\n\n//# sourceURL=webpack:///./src/js/iov/MqttTransport.js?")},"./src/js/iov/player.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar DEBUG_PREFIX = \'clsp:iov\';\nvar debug = debug__WEBPACK_IMPORTED_MODULE_0___default()(DEBUG_PREFIX + \':player\');\n\n/**\n * Responsible for receiving stream input and routing it to the media source\n * buffer for rendering on the video tag. There is some \'light\' reworking of\n * the binary data that is required.\n *\n * var player = iov.player();\n * player.play( video_element_id, stream_name );\n*/\n/* harmony default export */ __webpack_exports__["default"] = (function (iov) {\n    var self = {};\n\n    /*\n    Used for determining the size of the internal buffer hidden from the MSE\n    api by recording the size and time of each chunk of video upon buffer append\n    and recording the time when the updateend event is called.\n      */\n\n    self.LogSourceBuffer = false;\n    self.LogSourceBufferTopic = null;\n    self.state = "idle";\n    self.seqnum = 1;\n    self.seqnumProcessed = 1; // last sequence number processed\n    self.MAX_SEQ_PROC = 2;\n    self.dropCounter = 0;\n\n    self.moovBox = null;\n    self.moofBox = null;\n    // -1 is forever\n    self.retry_count = 3;\n    self.source_buffer_ready = false;\n\n    self._fault = function (err) {\n        //TODO: Change the video poster to a failure image\n        console.log(err);\n        self.state = "fault";\n    };\n\n    self.reinitializeMse = function () {\n        // reset counters, flags\n        self.seqnum = 1;\n        self.seqnumProcessed = 1; // last sequence number processed\n        self.source_buffer_ready = false;\n        self.dropCounter = 0;\n\n        // free resource\n        URL.revokeObjectURL(self.mediaSource);\n\n        // reallocate, this will call media source open which will\n        // append the MOOV atom.\n        self.video.src = URL.createObjectURL(self.mediaSource);\n    };\n\n    self.restart = function () {\n        self.stop();\n        self.play(self.eid, self.streamName, self.onFirstChunk, self.onVideoRecv);\n    };\n\n    self.play = function (eid, streamName, onFirstChunk, onVideoRecv) {\n        self.eid = eid;\n        self.streamName = streamName;\n        self.onFirstChunk = onFirstChunk;\n        self.video = document.getElementById(eid);\n        self.onVideoRecv = onVideoRecv;\n\n        if (typeof self.video === \'undefined\') {\n            self._fault("Unable to match id \'" + eid + "\'");\n            return;\n        }\n        var request = { clientId: iov.config.clientId };\n        var topic = "iov/video/" + window.btoa(self.streamName) + "/request";\n        iov.transport.transaction(topic, self._start_play, request);\n    };\n\n    self.resume = function (onFirstChunk, onVideoRecv) {\n        self.onFirstChunk = onFirstChunk;\n        self.onVideoRecv = onVideoRecv;\n\n        var request = { clientId: iov.config.clientId };\n        var topic = "iov/video/" + window.btoa(self.streamName) + "/request";\n        iov.transport.transaction(topic, self._start_play, request);\n    };\n\n    self._appendBuffer_event = function (bytearray) {\n        if (self.LogSourceBuffer === true && self.LogSourceBufferTopic !== null) {\n            //console.log("recording "+parseInt(bytearray.length)+" bytes of data");\n            var mqtt_msg = new Paho.MQTT.Message(bytearray);\n            mqtt_msg.destinationName = self.LogSourceBufferTopic;\n            MQTTClient.send(mqtt_msg);\n        }\n        // increment bytecount stats\n        iov.statsMsg.byteCount += bytearray.length;\n    };\n\n    self.stop = function () {\n        // stop streaming live video\n        if (typeof self.guid !== \'undefined\') {\n            iov.transport.unsubscribe("iov/video/" + self.guid + "/live");\n        }\n\n        self.state = "idle";\n\n        // free resources associated with player\n        self.seqnum = 1;\n        self.moovBox = null;\n        self.moofBox = null;\n\n        var request = { clientId: iov.config.clientId };\n        iov.transport.publish("iov/video/" + self.guid + "/stop", request);\n    };\n\n    self._start_play = function (resp) {\n        self.mimeCodec = resp.mimeCodec;\n        self.guid = resp.guid; // stream guid\n\n        if (\'MediaSource\' in window && MediaSource.isTypeSupported(self.mimeCodec)) {\n            var initseg_topic = iov.config.clientId + "/init-segment/" + parseInt(Math.random() * 1000000);\n\n            self._async_play_loop(resp, initseg_topic);\n            var play_request_topic = "iov/video/" + self.guid + "/play";\n            iov.transport.publish(play_request_topic, {\n                initSegmentTopic: initseg_topic,\n                clientId: iov.config.clientId\n            });\n        } else {\n            // the browser does not support this video format\n            self._fault("Unsuppored mime codec " + self.mimeCodec);\n        }\n    };\n\n    self._async_play_loop = function (resp, initSegmentTopic) {\n        // setup handlers for video\n        self.vqueue = []; // used if the media source buffer is busy\n\n        self.state = "waiting-for-moov";\n\n        iov.transport.subscribe(initSegmentTopic, function (mqtt_msg) {\n\n            // capture the initial segment\n            self.moovBox = mqtt_msg.payloadBytes;\n            //console.log(typeof mqtt_msg.payloadBytes);\n            //console.log("received moov from server");\n\n\n            self.state = "waiting-for-moof";\n            // unsubscribe to this group\n            iov.transport.unsubscribe(initSegmentTopic);\n\n            // subscribe to the live video topic.\n            self.state = "playing";\n            iov.transport.subscribe("iov/video/" + self.guid + "/live", self._on_moof);\n            // create media source buffer and start routing video traffic.\n\n\n            self.onFirstChunk(); // first chunk of video received.\n\n            self.mediaSource = new MediaSource();\n\n            var clone = self.video.cloneNode();\n            var parent = self.video.parentNode;\n            if (parent !== null) {\n                parent.replaceChild(clone, self.video);\n                self.video = clone;\n            }\n\n            self.mediaSource.addEventListener(\'sourceopen\', self._on_sourceopen);\n            self.mediaSource.addEventListener(\'sourceended\', self._on_sourceended);\n            self.mediaSource.addEventListener(\'error\', function (e) {\n                console.log("MSE error");\n                console.log(e);\n            });\n\n            // now assign media source extensions\n            //console.log("Disregard: The play() request was interrupted ... its not an error!");\n            self.video.src = URL.createObjectURL(self.mediaSource);\n\n            // subscribe to a sync topic that will be called if the stream that is feeding\n            // the mse service dies and has to be restarted that this player should restart the stream\n            var resync_topic = "iov/video/" + self.guid + "/resync";\n            console.log("Call " + resync_topic + " to resync stream");\n            iov.transport.subscribe(resync_topic, function (mqtt_msg) {\n                console.log("sync received re-initialize media source buffer");\n                self.reinitializeMse();\n            });\n        });\n    };\n\n    self._on_moof = function (mqtt_msg) {\n\n        if (self.source_buffer_ready == false) {\n            //console.log("media source not yet open dropping frame");\n            return;\n        }\n\n        /**\n            Enqueues or sends to the media source buffer an MP4 moof atom. This contains a\n            chunk of video/audio tracks.\n         */\n        // pace control. Allow a maximum of MAX_SEQ_PROC MOOF boxes to be held within\n        // the source buffer.\n        if (self.seqnum - self.seqnumProcessed > self.MAX_SEQ_PROC) {\n            //console.log("DROPPING FRAME DRIFT TOO HIGH, dropCounter = " + parseInt(self.dropCounter));\n            return; // DROP this frame since the borwser is falling\n        }\n\n        var moofBox = mqtt_msg.payloadBytes;\n        moofBox[20] = (self.seqnum & 0xFF000000) >> 24;\n        moofBox[21] = (self.seqnum & 0x00FF0000) >> 16;\n        moofBox[22] = (self.seqnum & 0x0000FF00) >> 8;\n        moofBox[23] = self.seqnum & 0xFF;\n\n        //console.log("moof handler: data seqnum chunk ");\n        //console.log(self.seqnum);\n\n        if (self.sourceBuffer.updating === false) {\n            try {\n                //console.log(typeof moofBox);\n                //console.log("calling append buffer");\n                self._appendBuffer_event(moofBox);\n                self.sourceBuffer.appendBuffer(moofBox);\n                self.seqnum += 1; // increment sequence number for next chunk\n            } catch (e) {\n                self.stop();\n                console.log(e.stack);\n                //var mseErrorEvt = new Event("mse-error-event");\n                //self.video.dispatchEvent(mseErrorEvt);\n            }\n        } else {\n            self.vqueue.push(moofBox.slice(0));\n        }\n    };\n\n    // found when stress testing many videos, it is possible for the\n    // media source ready state not to be open even though\n    // source open callback is being called.\n    self._on_sourceopen = function () {\n        if (self.mediaSource.readyState === "open") {\n            self._do_on_sourceopen();\n            return;\n        }\n\n        var t = setInterval(function () {\n            if (self.mediaSource.readyState === "open") {\n                self._do_on_sourceopen();\n                clearInterval(t);\n            }\n        }, 1000);\n    };\n\n    self._do_on_sourceopen = function () {\n        /** New media source opened. Add a buffer and append the moov MP4 video data.\n        */\n\n        // add buffer\n        self.sourceBuffer = self.mediaSource.addSourceBuffer(self.mimeCodec);\n        self.sourceBuffer.mode = "sequence";\n        self.sourceBuffer.addEventListener(\'updateend\', self._on_updateend);\n        self.sourceBuffer.addEventListener(\'update\', function () {\n            if (self.sourceBuffer.updating === false && self.vqueue.length > 0) {\n                self._appendBuffer_event(self.vqueue[0]);\n                self.sourceBuffer.appendBuffer(self.vqueue[0]);\n                self.vqueue = self.vqueue.slice(1);\n            }\n        });\n\n        self.sourceBuffer.addEventListener(\'updatestart\', function () {\n            //console.log("On update start");\n        });\n\n        self.sourceBuffer.addEventListener(\'error\', function (e) {\n            console.log("MSE sourceBffer error");\n            console.log(e);\n        });\n\n        // send ftype+moov segments of video\n        //console.log("sending moov atom ");\n\n        // we are now able to process video\n        self.source_buffer_ready = true;\n\n        self._appendBuffer_event(self.moovBox);\n        self.sourceBuffer.appendBuffer(self.moovBox);\n    };\n\n    self._on_sourceended = function () {\n        //console.log("sourceended");\n        self.stop();\n        self.source_buffer_ready = false;\n    };\n\n    self._on_updateend = function () {\n\n        // identify what seqnum of the MOOF message has actually been processed.\n        self.seqnumProcessed += 1;\n\n        /*\n        var logmsg =\n           "_on_updateend: " +\n           ((self.video.paused) ? " video is paused,": "video is playing,")   +\n           " ready state = \'" + self.mediaSource.readyState + "\', " +\n           " video queue size = " + parseInt(self.vqueue.length)\n        ;\n        console.log(logmsg);\n        */\n        if (self.mediaSource.readyState === "open") {\n            if (self.vqueue.length > 0) {\n                self._appendBuffer_event(self.vqueue[0]);\n                setTimeout(function () {\n                    // deqeue next prepared moof atom\n                    if (self.sourceBuffer.updating === false) {\n                        try {\n                            self.sourceBuffer.appendBuffer(self.vqueue[0]);\n                        } catch (ex) {\n                            // internal error, this has been observed to happen the tab\n                            // in the browser where this video player lives is hidden\n                            // then reselected. \'ex\' is undefined the error is bug\n                            // within the MSE C++ implementation in the browser.\n                        }\n                    }\n                    // regardless we must proceed to the frame.\n                    self.vqueue = self.vqueue.slice(1);\n                }, 0);\n            }\n\n            if (self.video.paused === true) {\n                try {\n                    var promise = self.video.play();\n                    if (typeof promise !== \'undefined\') {\n                        promise.then(function (_) {}).catch(function (e) {});\n                    }\n                } catch (ex) {\n                    console.log("Exception while trying to play:" + ex.message);\n                }\n                //console.log("setting video player from paused to play");\n            }\n        }\n    };\n\n    return self;\n});;\n\n//# sourceURL=webpack:///./src/js/iov/player.js?')},"./src/js/mseOverMqtt.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! video.js */ \"video.js\");\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(video_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/js/utils.js\");\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (defaults, SrcsLookupTable, onPlayerReady) {\n  /**\n   * A video.js plugin.\n   *\n   * In the plugin function, the value of `this` is a video.js `Player`\n   * instance. You cannot rely on the player being in a \"ready\" state here,\n   * depending on how the plugin is invoked. This may or may not be important\n   * to you; if not, remove the wait for \"ready\"!\n   *\n   * @function mseOverMqtt\n   * @param    {Object} [options={}]\n   *           An object of options left to the plugin author to define.\n   */\n  var mseOverMqtt = function mseOverMqtt(options) {\n    var _this = this;\n\n    this.errors({\n      errors: {\n        PLAYER_ERR_NOT_COMPAT: {\n          headline: 'This browser is unsupported.',\n          message: 'Chrome 52+ is required.'\n        }\n      }\n    });\n\n    if (_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].supported() === false) {\n      this.error({ code: 'PLAYER_ERR_NOT_COMPAT', dismiss: false });\n      return;\n    }\n\n    this.on('firstplay', function (e) {\n      var spinner = this.player_.loadingSpinner;\n      var videojs_player = this.player_;\n\n      // work around bogus error code.\n      var old_error = Object.assign({}, videojs_player.error());\n      videojs_player.error = function (evt) {\n        if (typeof evt === 'undefined') {\n          return old_error;\n        }\n\n        if (evt === null) {\n          return;\n        }\n\n        if (evt.code !== -2) {\n          videojs_player.old_error(evt);\n        }\n      };\n\n      var source_tag = this.currentSource();\n      if (!(source_tag.src in SrcsLookupTable)) {\n        console.error('src not in lookup table');\n        return;\n      }\n\n      var h = SrcsLookupTable[source_tag.src];\n      // setup mqtt connection, callback called when connection\n      // made and a new iov_player created.\n      h.launchIovPlayer(function (iov_player) {\n        if (iov_player === null || iov_player.playing === true) {\n          return;\n        }\n\n        iov_player.playing = true;\n\n        // dynamically alter the control bar below the video tag.\n        function setupControlBar() {\n          videojs_player.controlBar.addClass('vjs-live');\n          window._ThePlayer = videojs_player;\n\n          var playToggle = videojs_player.controlBar.children_[0].el_;\n          playToggle.addEventListener('click', function () {\n            // @todo - is this setTimeout necessary?\n            setTimeout(function () {\n              if (iov_player.playing === true) {\n                iov_player.stop();\n                iov_player.playing = false;\n                videojs_player.controlBar.playToggle.handlePause();\n                return;\n              }\n\n              spinner.show();\n\n              iov_player.resume(function () {\n                // @todo - is this setTimeout necessary?\n                setTimeout(function () {\n                  spinner.hide();\n                }, 0);\n              }, function () {\n                // reset the timeout monitor\n                videojs_player.trigger('timeupdate');\n              });\n\n              iov_player.playing = true;\n              videojs_player.controlBar.playToggle.handlePlay();\n            }, 0);\n          });\n        }\n\n        // start playing video\n        iov_player.play(e.target.firstChild.id, h.streamName, function () {\n          // @todo - is this setTimeout necessary?\n          // dispose of spinner after page refresh.\n          setTimeout(function () {\n            // spinner.dispose();\n            spinner.hide();\n            // toggle play button\n            videojs_player.controlBar.playToggle.handlePlay();\n            // alter the control bar\n            setupControlBar();\n          }, 0);\n        }, function () {\n          // reset the timeout monitor\n          videojs_player.trigger('timeupdate');\n        });\n      });\n    });\n\n    this.ready(function () {\n      var videoTag = _this.children()[0];\n      // var playButton = this.bigPlayButton;\n\n      videoTag.addEventListener('mqttReady', function (event) {\n        if (videoTag.getAttribute('autoplay') !== null) {\n          // playButton.trigger('click');\n          _this.trigger('play', videoTag);\n        }\n      });\n\n      onPlayerReady(_this, video_js__WEBPACK_IMPORTED_MODULE_0___default.a.mergeOptions(defaults, options));\n    });\n  };\n\n  return mseOverMqtt;\n});\n\n//# sourceURL=webpack:///./src/js/mseOverMqtt.js?")},"./src/js/utils.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\nvar MINIMUM_CHROME_VERSION = 52;\n\nfunction browserIsCompatable() {\n  // Chrome 1+\n  var isChrome = Boolean(window.chrome) && Boolean(window.chrome.webstore);\n\n  if (!isChrome) {\n    return false;\n  }\n\n  try {\n    return parseInt(navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./)[2], 10) >= MINIMUM_CHROME_VERSION;\n  } catch (error) {\n    return false;\n  }\n}\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  supported: browserIsCompatable\n});\n\n//# sourceURL=webpack:///./src/js/utils.js?')},"./src/js/videojs-mse-over-clsp.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! video.js */ "video.js");\n/* harmony import */ var video_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(video_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var videojs_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! videojs-errors */ "./node_modules/videojs-errors/dist/videojs-errors.es.js");\n/* harmony import */ var srcdoc_polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! srcdoc-polyfill */ "./node_modules/srcdoc-polyfill/srcdoc-polyfill.js");\n/* harmony import */ var srcdoc_polyfill__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(srcdoc_polyfill__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _conduit_clspConduit_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./conduit/clspConduit.generated.js */ "./src/js/conduit/clspConduit.generated.js");\n/* harmony import */ var _conduit_clspConduit_generated_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_conduit_clspConduit_generated_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../package.json */ "./package.json");\nvar _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/Object.assign({}, _package_json__WEBPACK_IMPORTED_MODULE_4__, {"default": _package_json__WEBPACK_IMPORTED_MODULE_4__});\n/* harmony import */ var _MqttHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MqttHandler */ "./src/js/MqttHandler.js");\n/* harmony import */ var _MqttSourceHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MqttSourceHandler */ "./src/js/MqttSourceHandler.js");\n/* harmony import */ var _mseOverMqtt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mseOverMqtt */ "./src/js/mseOverMqtt.js");\n/* harmony import */ var _styles_videojs_mse_over_clsp_scss__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../styles/videojs-mse-over-clsp.scss */ "./src/styles/videojs-mse-over-clsp.scss");\n/* harmony import */ var _styles_videojs_mse_over_clsp_scss__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_styles_videojs_mse_over_clsp_scss__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n// import \'./conduit/clspConduit.generated.min.js\';\n\n\n\n\n\n\n\n\nvar SrcsLookupTable = {};\n\nvar mqttHandler = Object(_MqttHandler__WEBPACK_IMPORTED_MODULE_5__["default"])(SrcsLookupTable);\nvar mqttSourceHandler = Object(_MqttSourceHandler__WEBPACK_IMPORTED_MODULE_6__["default"])(mqttHandler);\n\nvideo_js__WEBPACK_IMPORTED_MODULE_0___default.a.mqttSupported = true;\nvideo_js__WEBPACK_IMPORTED_MODULE_0___default.a.mqttHandler = mqttHandler;\nvideo_js__WEBPACK_IMPORTED_MODULE_0___default.a.mqttSourceHandler = mqttSourceHandler;\nvideo_js__WEBPACK_IMPORTED_MODULE_0___default.a.getTech(\'Html5\').registerSourceHandler(mqttSourceHandler(\'html5\'), 0);\n\n// Default options for the plugin.\nvar defaults = {};\n\n/**\n * Function to invoke when the player is ready.\n *\n * This is a great place for your plugin to initialize itself. When this\n * function is called, the player will have its DOM and child components\n * in place.\n *\n * @function onPlayerReady\n * @param    {Player} player\n *           A Video.js player object.\n *\n * @param    {Object} [options={}]\n *           A plain object containing options for the plugin.\n */\nvar onPlayerReady = function onPlayerReady(player, options) {\n  player.addClass(\'vjs-mse-over-mqtt\');\n};\n\nvar clspPlugin = Object(_mseOverMqtt__WEBPACK_IMPORTED_MODULE_7__["default"])(defaults, SrcsLookupTable, onPlayerReady);\n\n// Cross-compatibility for Video.js 5 and 6.\nvar registerPlugin = video_js__WEBPACK_IMPORTED_MODULE_0___default.a.registerPlugin || video_js__WEBPACK_IMPORTED_MODULE_0___default.a.plugin;\n\n// Register the plugin with video.js.\nregisterPlugin(\'clsp\', clspPlugin);\n\n// Include the version number.\nclspPlugin.VERSION = _package_json__WEBPACK_IMPORTED_MODULE_4__["version"];\n\n/* harmony default export */ __webpack_exports__["default"] = (clspPlugin);\n\n//# sourceURL=webpack:///./src/js/videojs-mse-over-clsp.js?')},"./src/styles/videojs-mse-over-clsp.scss":function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./src/styles/videojs-mse-over-clsp.scss?")},0:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack:///min-document_(ignored)?")},"video.js":function(module,exports){eval("module.exports = videojs;\n\n//# sourceURL=webpack:///external_%22videojs%22?")}});